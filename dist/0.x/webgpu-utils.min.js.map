{"version":3,"file":"webgpu-utils.min.js","sources":["../../src/3rdParty/wgsl_reflect/wgsl_reflect.module.js","../../../src/webgpu-utils.ts"],"sourcesContent":["/**\r\n * @author Brendan Duncan / https://github.com/brendan-duncan\r\n */\r\n\r\nclass Token {\r\n    constructor(type, lexeme, line) {\r\n        this._type = type;\r\n        this._lexeme = lexeme;\r\n        this._line = line;\r\n    }\r\n\r\n    toString() {\r\n        return this._lexeme;\r\n    }\r\n}\r\n\r\nToken.EOF = { name: \"EOF\", type: \"token\", rule: -1 };\r\n\r\nlet Keyword = {};\r\n\r\nclass WgslScanner {\r\n    constructor(source) {\r\n        this._source = source || \"\";\r\n        this._tokens = [];\r\n        this._start = 0;\r\n        this._current = 0;\r\n        this._line = 1;\r\n    }\r\n\r\n    scanTokens() {\r\n        while (!this._isAtEnd()) {\r\n            this._start = this._current;\r\n            if (!this.scanToken())\r\n                throw `Invalid syntax at line ${this._line}`;\r\n        }\r\n\r\n        this._tokens.push(new Token(Token.EOF, \"\", this._line));\r\n        return this._tokens;\r\n    }\r\n\r\n    scanToken() {\r\n        // Find the longest consecutive set of characters that match a rule.\r\n        let lexeme = this._advance();\r\n\r\n        // Skip line-feed, adding to the line counter.\r\n        if (lexeme == \"\\n\") {\r\n            this._line++;\r\n            return true;\r\n        }\r\n\r\n        // Skip whitespace\r\n        if (this._isWhitespace(lexeme)) {\r\n            return true;\r\n        }\r\n\r\n        if (lexeme == \"/\") {\r\n            // If it's a // comment, skip everything until the next line-feed.\r\n            if (this._peekAhead() == \"/\") {\r\n                while (lexeme != \"\\n\") {\r\n                    if (this._isAtEnd())\r\n                        return true;\r\n                    lexeme = this._advance();\r\n                }\r\n                // skip the linefeed\r\n                this._line++;\r\n                return true;\r\n            } else if (this._peekAhead() == \"*\") {\r\n                // If it's a /* block comment, skip everything until the matching */,\r\n                // allowing for nested block comments.\r\n                this._advance();\r\n                let commentLevel = 1;\r\n                while (commentLevel > 0) {\r\n                    if (this._isAtEnd())\r\n                        return true;\r\n                    lexeme = this._advance();\r\n                    if (lexeme == \"\\n\") {\r\n                        this._line++;\r\n                    } else if (lexeme == \"*\") {\r\n                        if (this._peekAhead() == \"/\") {\r\n                            this._advance();\r\n                            commentLevel--;\r\n                            if (commentLevel == 0) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    } else if (lexeme == \"/\") {\r\n                        if (this._peekAhead() == \"*\") {\r\n                            this._advance();\r\n                            commentLevel++;\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n\r\n        let matchToken = null;\r\n\r\n        for (;;) {\r\n            let matchedToken = this._findToken(lexeme);\r\n\r\n            // The exception to \"longest lexeme\" rule is '>>'. In the case of 1>>2, it's a shift_right.\r\n            // In the case of array<vec4<f32>>, it's two greater_than's (one to close the vec4,\r\n            // and one to close the array).\r\n            // I don't know of a great way to resolve this, so '>>' is special-cased and if\r\n            // there was a less_than up to some number of tokens previously, and the token prior to\r\n            // that is a keyword that requires a '<', then it will be split into two greater_than's;\r\n            // otherwise it's a shift_right.\r\n            if (lexeme == \">\" && this._peekAhead() == \">\") {\r\n                let foundLessThan = false;\r\n                let ti = this._tokens.length - 1;\r\n                for (let count = 0; count < 4 && ti >= 0; ++count, --ti) {\r\n                    if (this._tokens[ti]._type == Token.less_than) {\r\n                        if (ti > 0 && Token.template_types.indexOf(this._tokens[ti - 1]._type) != -1) {\r\n                            foundLessThan = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                // If there was a less_than in the recent token history, then this is probably a\r\n                // greater_than.\r\n                if (foundLessThan) {\r\n                    this._addToken(matchedToken);\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // The current lexeme may not match any rule, but some token types may be invalid for\r\n            // part of the string but valid after a few more characters.\r\n            // For example, 0x.5 is a hex_float_literal. But as it's being scanned,\r\n            // \"0\" is a int_literal, then \"0x\" is invalid. If we stopped there, it would return\r\n            // the int_literal \"0\", but that's incorrect. So if we look forward a few characters,\r\n            // we'd get \"0x.\", which is still invalid, followed by \"0x.5\" which is the correct\r\n            // hex_float_literal. So that means if we hit an non-matching string, we should look\r\n            // ahead up to two characters to see if the string starts matching a valid rule again.\r\n            if (!matchedToken) {\r\n                let lookAheadLexeme = lexeme;\r\n                let lookAhead = 0;\r\n                const maxLookAhead = 2;\r\n                for (let li = 0; li < maxLookAhead; ++li) {\r\n                    lookAheadLexeme += this._peekAhead(li);\r\n                    matchedToken = this._findToken(lookAheadLexeme);\r\n                    if (matchedToken) {\r\n                        lookAhead = li;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!matchedToken) {\r\n                    if (!matchToken)\r\n                        return false;\r\n                    this._current--;\r\n                    this._addToken(matchToken);\r\n                    return true;\r\n                }\r\n\r\n                lexeme = lookAheadLexeme;\r\n                this._current += lookAhead + 1;\r\n            }\r\n\r\n            matchToken = matchedToken;\r\n\r\n            if (this._isAtEnd())\r\n                break;\r\n\r\n            lexeme += this._advance();\r\n        }\r\n\r\n        // We got to the end of the input stream. Then the token we've ready so far is it.\r\n        if (matchToken === null)\r\n            return false;\r\n\r\n        this._addToken(matchToken);\r\n        return true;\r\n    }\r\n\r\n    _findToken(lexeme) {\r\n        for (const name in Keyword) {\r\n            const token = Keyword[name];\r\n            if (this._match(lexeme, token.rule)) {\r\n                return token;\r\n            }\r\n        }\r\n        for (const name in Token.Tokens) {\r\n            const token = Token.Tokens[name];\r\n            if (this._match(lexeme, token.rule)) {\r\n                return token;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _match(lexeme, rule) {\r\n        if (typeof(rule) == \"string\") {\r\n            if (rule == lexeme) {\r\n                return true;\r\n            }\r\n        } else {\r\n            // regex\r\n            const match = rule.exec(lexeme);\r\n            if (match && match.index == 0 && match[0] == lexeme)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    _isAtEnd() {\r\n        return this._current >= this._source.length;\r\n    }\r\n\r\n    _isWhitespace(c) {\r\n        return c == \" \" || c == \"\\t\" || c == \"\\r\";\r\n    }\r\n\r\n    _advance(amount) {\r\n        let c = this._source[this._current];\r\n        amount = amount || 0;\r\n        amount++;\r\n        this._current += amount;\r\n        return c;\r\n    }\r\n\r\n    _peekAhead(offset) {\r\n        offset = offset || 0;\r\n        if (this._current + offset >= this._source.length) return \"\\0\";\r\n        return this._source[this._current + offset];\r\n    }\r\n\r\n    _addToken(type) {\r\n        const text = this._source.substring(this._start, this._current);\r\n        this._tokens.push(new Token(type, text, this._line));\r\n    }\r\n}\r\n\r\nToken.WgslTokens = {\r\n    decimal_float_literal:\r\n        /((-?[0-9]*\\.[0-9]+|-?[0-9]+\\.[0-9]*)((e|E)(\\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\\+|-)?[0-9]+f?)/,\r\n    hex_float_literal:\r\n        /-?0x((([0-9a-fA-F]*\\.[0-9a-fA-F]+|[0-9a-fA-F]+\\.[0-9a-fA-F]*)((p|P)(\\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\\+|-)?[0-9]+f?))/,\r\n    int_literal:\r\n        /-?0x[0-9a-fA-F]+|0|-?[1-9][0-9]*/,\r\n    uint_literal:\r\n        /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/,\r\n    ident:\r\n        /[a-zA-Z][0-9a-zA-Z_]*/,\r\n    and:\r\n        '&',\r\n    and_and:\r\n        '&&',\r\n    arrow :\r\n        '->',\r\n    attr:\r\n        '@',\r\n    attr_left:\r\n        '[[',\r\n    attr_right:\r\n        ']]',\r\n    forward_slash:\r\n        '/',\r\n    bang:\r\n        '!',\r\n    bracket_left:\r\n        '[',\r\n    bracket_right:\r\n        ']',\r\n    brace_left:\r\n        '{',\r\n    brace_right:\r\n        '}',\r\n    colon:\r\n        ':',\r\n    comma:\r\n        ',',\r\n    equal:\r\n        '=',\r\n    equal_equal:\r\n        '==',\r\n    not_equal:\r\n        '!=',\r\n    greater_than:\r\n        '>',\r\n    greater_than_equal:\r\n        '>=',\r\n    shift_right:\r\n        '>>',\r\n    less_than:\r\n        '<',\r\n    less_than_equal:\r\n        '<=',\r\n    shift_left:\r\n        '<<',\r\n    modulo:\r\n        '%',\r\n    minus:\r\n        '-',\r\n    minus_minus:\r\n        '--',\r\n    period:\r\n        '.',\r\n    plus:\r\n        '+',\r\n    plus_plus:\r\n        '++',\r\n    or:\r\n        '|',\r\n    or_or:\r\n        '||',\r\n    paren_left:\r\n        '(',\r\n    paren_right:\r\n        ')',\r\n    semicolon:\r\n        ';',\r\n    star:\r\n        '*',\r\n    tilde:\r\n        '~',\r\n    underscore:\r\n        '_',\r\n    xor:\r\n        '^',\r\n\r\n    plus_equal:\r\n        '+=',\r\n    minus_equal:\r\n        '-=',\r\n    times_equal:\r\n        '*=',\r\n    division_equal:\r\n        '/=',\r\n    modulo_equal:\r\n        '%=',\r\n    and_equal:\r\n        '&=',\r\n    or_equal:\r\n        '|=',\r\n    xor_equal:\r\n        '^=',\r\n    shift_right_equal:\r\n        '>>=',\r\n    shift_left_equal:\r\n        '<<=',\r\n};\r\n\r\nToken.WgslKeywords = [\r\n    \"array\",\r\n    \"atomic\",\r\n    \"bool\",\r\n    \"f32\",\r\n    \"i32\",\r\n    \"mat2x2\",\r\n    \"mat2x3\",\r\n    \"mat2x4\",\r\n    \"mat3x2\",\r\n    \"mat3x3\",\r\n    \"mat3x4\",\r\n    \"mat4x2\",\r\n    \"mat4x3\",\r\n    \"mat4x4\",\r\n    \"ptr\",\r\n    \"sampler\",\r\n    \"sampler_comparison\",\r\n    \"struct\",\r\n    \"texture_1d\",\r\n    \"texture_2d\",\r\n    \"texture_2d_array\",\r\n    \"texture_3d\",\r\n    \"texture_cube\",\r\n    \"texture_cube_array\",\r\n    \"texture_multisampled_2d\",\r\n    \"texture_storage_1d\",\r\n    \"texture_storage_2d\",\r\n    \"texture_storage_2d_array\",\r\n    \"texture_storage_3d\",\r\n    \"texture_depth_2d\",\r\n    \"texture_depth_2d_array\",\r\n    \"texture_depth_cube\",\r\n    \"texture_depth_cube_array\",\r\n    \"texture_depth_multisampled_2d\",\r\n    \"u32\",\r\n    \"vec2\",\r\n    \"vec3\",\r\n    \"vec4\",\r\n    \"bitcast\",\r\n    \"block\",\r\n    \"break\",\r\n    \"case\",\r\n    \"continue\",\r\n    \"continuing\",\r\n    \"default\",\r\n    \"discard\",\r\n    \"else\",\r\n    \"elseif\",\r\n    \"enable\",\r\n    \"fallthrough\",\r\n    \"false\",\r\n    \"fn\",\r\n    \"for\",\r\n    \"function\",\r\n    \"if\",\r\n    \"let\",\r\n    \"const\",\r\n    \"loop\",\r\n    \"while\",\r\n    \"private\",\r\n    \"read\",\r\n    \"read_write\",\r\n    \"return\",\r\n    \"storage\",\r\n    \"switch\",\r\n    \"true\",\r\n    \"type\",\r\n    \"uniform\",\r\n    \"var\",\r\n    \"workgroup\",\r\n    \"write\",\r\n    \"r8unorm\",\r\n    \"r8snorm\",\r\n    \"r8uint\",\r\n    \"r8sint\",\r\n    \"r16uint\",\r\n    \"r16sint\",\r\n    \"r16float\",\r\n    \"rg8unorm\",\r\n    \"rg8snorm\",\r\n    \"rg8uint\",\r\n    \"rg8sint\",\r\n    \"r32uint\",\r\n    \"r32sint\",\r\n    \"r32float\",\r\n    \"rg16uint\",\r\n    \"rg16sint\",\r\n    \"rg16float\",\r\n    \"rgba8unorm\",\r\n    \"rgba8unorm_srgb\",\r\n    \"rgba8snorm\",\r\n    \"rgba8uint\",\r\n    \"rgba8sint\",\r\n    \"bgra8unorm\",\r\n    \"bgra8unorm_srgb\",\r\n    \"rgb10a2unorm\",\r\n    \"rg11b10float\",\r\n    \"rg32uint\",\r\n    \"rg32sint\",\r\n    \"rg32float\",\r\n    \"rgba16uint\",\r\n    \"rgba16sint\",\r\n    \"rgba16float\",\r\n    \"rgba32uint\",\r\n    \"rgba32sint\",\r\n    \"rgba32float\",\r\n    \"static_assert\"\r\n];\r\n\r\nToken.WgslReserved = [\r\n    \"asm\",\r\n    \"bf16\",\r\n    \"do\",\r\n    \"enum\",\r\n    \"f16\",\r\n    \"f64\",\r\n    \"handle\",\r\n    \"i8\",\r\n    \"i16\",\r\n    \"i64\",\r\n    \"mat\",\r\n    \"premerge\",\r\n    \"regardless\",\r\n    \"typedef\",\r\n    \"u8\",\r\n    \"u16\",\r\n    \"u64\",\r\n    \"unless\",\r\n    \"using\",\r\n    \"vec\",\r\n    \"void\"\r\n];\r\n\r\nfunction _InitTokens() {\r\n    Token.Tokens = {};\r\n    for (let token in Token.WgslTokens) {\r\n        Token.Tokens[token] = {\r\n            name: token,\r\n            type: \"token\",\r\n            rule: Token.WgslTokens[token],\r\n            toString: function() { return token; }\r\n        };\r\n        Token[token] = Token.Tokens[token];\r\n    }\r\n\r\n    for (let i = 0, l = Token.WgslKeywords.length; i < l; ++i) {\r\n        Keyword[Token.WgslKeywords[i]] = {\r\n            name: Token.WgslKeywords[i],\r\n            type: \"keyword\",\r\n            rule: Token.WgslKeywords[i],\r\n            toString: function() { return Token.WgslKeywords[i]; }\r\n        };\r\n    }\r\n\r\n    for (let i = 0, l = Token.WgslReserved.length; i < l; ++i) {\r\n        Keyword[Token.WgslReserved[i]] = {\r\n            name: Token.WgslReserved[i], \r\n            type: \"reserved\",\r\n            rule: Token.WgslReserved[i],\r\n            toString: function() { return Token.WgslReserved[i]; }\r\n        };\r\n    }\r\n\r\n    // WGSL grammar has a few keywords that have different token names than the strings they\r\n    // represent. Aliasing them here.\r\n\r\n    Keyword.int32 = Keyword.i32;\r\n    Keyword.uint32 = Keyword.u32;\r\n    Keyword.float32 = Keyword.f32;\r\n    Keyword.pointer = Keyword.ptr;\r\n\r\n    // The grammar has a few rules where the rule can match to any one of a given set of keywords\r\n    // or tokens. Defining those here.\r\n\r\n    Token.storage_class = [\r\n        Keyword.function,\r\n        Keyword.private,\r\n        Keyword.workgroup,\r\n        Keyword.uniform,\r\n        Keyword.storage\r\n    ];\r\n    \r\n    Token.access_mode = [\r\n        Keyword.read,\r\n        Keyword.write,\r\n        Keyword.read_write\r\n    ];\r\n    \r\n    Token.sampler_type = [\r\n        Keyword.sampler,\r\n        Keyword.sampler_comparison\r\n    ];\r\n    \r\n    Token.sampled_texture_type = [\r\n        Keyword.texture_1d,\r\n        Keyword.texture_2d,\r\n        Keyword.texture_2d_array,\r\n        Keyword.texture_3d,\r\n        Keyword.texture_cube,\r\n        Keyword.texture_cube_array\r\n    ];\r\n    \r\n    Token.multisampled_texture_type = [\r\n        Keyword.texture_multisampled_2d\r\n    ];\r\n    \r\n    Token.storage_texture_type = [\r\n        Keyword.texture_storage_1d,\r\n        Keyword.texture_storage_2d,\r\n        Keyword.texture_storage_2d_array,\r\n        Keyword.texture_storage_3d\r\n    ];\r\n    \r\n    Token.depth_texture_type = [\r\n        Keyword.texture_depth_2d,\r\n        Keyword.texture_depth_2d_array,\r\n        Keyword.texture_depth_cube,\r\n        Keyword.texture_depth_cube_array,\r\n        Keyword.texture_depth_multisampled_2d\r\n    ];\r\n\r\n    Token.any_texture_type = [\r\n        ...Token.sampled_texture_type,\r\n        ...Token.multisampled_texture_type,\r\n        ...Token.storage_texture_type,\r\n        ...Token.depth_texture_type\r\n    ];\r\n\r\n    Token.texel_format = [\r\n        Keyword.r8unorm,\r\n        Keyword.r8snorm,\r\n        Keyword.r8uint,\r\n        Keyword.r8sint,\r\n        Keyword.r16uint,\r\n        Keyword.r16sint,\r\n        Keyword.r16float,\r\n        Keyword.rg8unorm,\r\n        Keyword.rg8snorm,\r\n        Keyword.rg8uint,\r\n        Keyword.rg8sint,\r\n        Keyword.r32uint,\r\n        Keyword.r32sint,\r\n        Keyword.r32float,\r\n        Keyword.rg16uint,\r\n        Keyword.rg16sint,\r\n        Keyword.rg16float,\r\n        Keyword.rgba8unorm,\r\n        Keyword.rgba8unorm_srgb,\r\n        Keyword.rgba8snorm,\r\n        Keyword.rgba8uint,\r\n        Keyword.rgba8sint,\r\n        Keyword.bgra8unorm,\r\n        Keyword.bgra8unorm_srgb,\r\n        Keyword.rgb10a2unorm,\r\n        Keyword.rg11b10float,\r\n        Keyword.rg32uint,\r\n        Keyword.rg32sint,\r\n        Keyword.rg32float,\r\n        Keyword.rgba16uint,\r\n        Keyword.rgba16sint,\r\n        Keyword.rgba16float,\r\n        Keyword.rgba32uint,\r\n        Keyword.rgba32sint,\r\n        Keyword.rgba32float\r\n    ];\r\n\r\n    Token.const_literal = [\r\n        Token.int_literal,\r\n        Token.uint_literal,\r\n        Token.decimal_float_literal,\r\n        Token.hex_float_literal,\r\n        Keyword.true,\r\n        Keyword.false\r\n    ];\r\n\r\n    Token.literal_or_ident = [\r\n        Token.ident,\r\n        Token.int_literal,\r\n        Token.uint_literal,\r\n        Token.decimal_float_literal,\r\n        Token.hex_float_literal,\r\n    ];\r\n\r\n    Token.element_count_expression = [\r\n        Token.int_literal,\r\n        Token.uint_literal,\r\n        Token.ident\r\n    ];\r\n\r\n    Token.template_types = [\r\n        Keyword.vec2,\r\n        Keyword.vec3,\r\n        Keyword.vec4,\r\n        Keyword.mat2x2,\r\n        Keyword.mat2x3,\r\n        Keyword.mat2x4,\r\n        Keyword.mat3x2,\r\n        Keyword.mat3x3,\r\n        Keyword.mat3x4,\r\n        Keyword.mat4x2,\r\n        Keyword.mat4x3,\r\n        Keyword.mat4x4,\r\n        Keyword.atomic,\r\n\r\n        Keyword.bitcast,\r\n\r\n        ...Token.any_texture_type,\r\n    ];\r\n\r\n    // The grammar calls out 'block', but attribute grammar is defined to use a 'ident'.\r\n    // The attribute grammar should be ident | block.\r\n    Token.attribute_name = [\r\n        Token.ident,\r\n        Keyword.block,\r\n    ];\r\n\r\n    Token.assignment_operators = [\r\n        Token.equal,\r\n        Token.plus_equal,\r\n        Token.minus_equal,\r\n        Token.times_equal,\r\n        Token.division_equal,\r\n        Token.modulo_equal,\r\n        Token.and_equal,\r\n        Token.or_equal,\r\n        Token.xor_equal,\r\n        Token.shift_right_equal,\r\n        Token.shift_left_equal\r\n    ];\r\n\r\n    Token.increment_operators = [\r\n        Token.plus_plus,\r\n        Token.minus_minus\r\n    ];\r\n}\r\n_InitTokens();\r\n\r\n/**\r\n * @author Brendan Duncan / https://github.com/brendan-duncan\r\n */\r\n\r\nclass AST {\r\n    constructor(type, options) {\r\n        this._type = type;\r\n        if (options) {\r\n            for (let option in options) {\r\n                this[option] = options[option];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass WgslParser {\r\n    constructor() {\r\n        this._tokens = [];\r\n        this._current = 0;\r\n    }\r\n\r\n    parse(tokensOrCode) {\r\n        this._initialize(tokensOrCode);\r\n\r\n        let statements = [];\r\n        while (!this._isAtEnd()) {\r\n            const statement = this._global_decl_or_directive();\r\n            if (!statement)\r\n                break;\r\n            statements.push(statement);\r\n        }\r\n        return statements;\r\n    }\r\n\r\n    _initialize(tokensOrCode) {\r\n        if (tokensOrCode) {\r\n            if (typeof(tokensOrCode) == \"string\") {\r\n                const scanner = new WgslScanner(tokensOrCode);\r\n                this._tokens = scanner.scanTokens();\r\n            } else {\r\n                this._tokens = tokensOrCode;\r\n            }\r\n        } else {\r\n            this._tokens = [];\r\n        }\r\n        this._current = 0;\r\n    }\r\n\r\n    _error(token, message) {\r\n        console.error(token, message);\r\n        return { token, message, toString: function() { return `${message}`; } };\r\n    }\r\n\r\n    _isAtEnd() { return this._current >= this._tokens.length || this._peek()._type == Token.EOF; }\r\n\r\n    _match(types) {\r\n        if (types.length === undefined) {\r\n            if (this._check(types)) {\r\n                this._advance();\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0, l = types.length; i < l; ++i) {\r\n            const type = types[i];\r\n            if (this._check(type)) {\r\n                this._advance();\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    _consume(types, message) {\r\n        if (this._check(types)) return this._advance();\r\n        throw this._error(this._peek(), message);\r\n    }\r\n\r\n    _check(types) {\r\n        if (this._isAtEnd()) return false;\r\n        if (types.length !== undefined) {\r\n            let t = this._peek()._type;\r\n            return types.indexOf(t) != -1;\r\n        }\r\n        return this._peek()._type == types;\r\n    }\r\n\r\n    _advance() {\r\n        if (!this._isAtEnd()) this._current++;\r\n        return this._previous();\r\n    }\r\n\r\n    _peek() {\r\n        return this._tokens[this._current];\r\n    }\r\n\r\n    _previous() {\r\n        return this._tokens[this._current - 1];\r\n    }\r\n\r\n    _global_decl_or_directive() {\r\n        // semicolon\r\n        // global_variable_decl semicolon\r\n        // global_constant_decl semicolon\r\n        // type_alias semicolon\r\n        // struct_decl\r\n        // function_decl\r\n        // enable_directive\r\n\r\n        // Ignore any stand-alone semicolons\r\n        while (this._match(Token.semicolon) && !this._isAtEnd());\r\n\r\n        if (this._match(Keyword.type)) {\r\n            const type = this._type_alias();\r\n            this._consume(Token.semicolon, \"Expected ';'\");\r\n            return type;\r\n        }\r\n\r\n        if (this._match(Keyword.enable)) {\r\n            const enable = this._enable_directive();\r\n            this._consume(Token.semicolon, \"Expected ';'\");\r\n            return enable;\r\n        }\r\n\r\n        // The following statements have an optional attribute*\r\n        const attrs = this._attribute();\r\n\r\n        if (this._check(Keyword.var)) {\r\n            const _var = this._global_variable_decl();\r\n            _var.attributes = attrs;\r\n            this._consume(Token.semicolon, \"Expected ';'.\");\r\n            return _var;\r\n        }\r\n\r\n        if (this._check(Keyword.let)) {\r\n            const _let = this._global_constant_decl();\r\n            _let.attributes = attrs;\r\n            this._consume(Token.semicolon, \"Expected ';'.\");\r\n            return _let;\r\n        }\r\n\r\n        if (this._check(Keyword.struct)) {\r\n            const _struct = this._struct_decl();\r\n            _struct.attributes = attrs;\r\n            return _struct;\r\n        }\r\n\r\n        if (this._check(Keyword.fn)) {\r\n            const _fn = this._function_decl();\r\n            _fn.attributes = attrs;\r\n            return _fn;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    _function_decl() {\r\n        // attribute* function_header compound_statement\r\n        // function_header: fn ident paren_left param_list? paren_right (arrow attribute* type_decl)?\r\n        if (!this._match(Keyword.fn))\r\n            return null;\r\n\r\n        const name = this._consume(Token.ident, \"Expected function name.\").toString();\r\n\r\n        this._consume(Token.paren_left, \"Expected '(' for function arguments.\");\r\n\r\n        const args = [];\r\n        if (!this._check(Token.paren_right)) {\r\n            do {\r\n                if (this._check(Token.paren_right))\r\n                    break;\r\n                const argAttrs = this._attribute();\r\n\r\n                const name = this._consume(Token.ident, \"Expected argument name.\").toString();\r\n\r\n                this._consume(Token.colon, \"Expected ':' for argument type.\");\r\n                \r\n                const typeAttrs = this._attribute();\r\n                const type = this._type_decl();\r\n                type.attributes = typeAttrs;\r\n\r\n                args.push(new AST(\"arg\", { name, attributes: argAttrs, type }));\r\n            } while (this._match(Token.comma));\r\n        }\r\n\r\n        this._consume(Token.paren_right, \"Expected ')' after function arguments.\");\r\n\r\n        let _return = null;\r\n        if (this._match(Token.arrow)) {\r\n            const attrs = this._attribute();\r\n            _return = this._type_decl();\r\n            _return.attributes = attrs;\r\n        }\r\n\r\n        const body = this._compound_statement();\r\n\r\n        return new AST(\"function\", { name, args, return: _return, body });\r\n    }\r\n\r\n    _compound_statement() {\r\n        // brace_left statement* brace_right\r\n        const statements = [];\r\n        this._consume(Token.brace_left, \"Expected '{' for block.\");\r\n        while (!this._check(Token.brace_right)) {\r\n            const statement = this._statement();\r\n            if (statement)\r\n                statements.push(statement);\r\n        }\r\n        this._consume(Token.brace_right, \"Expected '}' for block.\");\r\n\r\n        return statements;\r\n    }\r\n\r\n    _statement() {\r\n        // semicolon\r\n        // return_statement semicolon\r\n        // if_statement\r\n        // switch_statement\r\n        // loop_statement\r\n        // for_statement\r\n        // func_call_statement semicolon\r\n        // variable_statement semicolon\r\n        // break_statement semicolon\r\n        // continue_statement semicolon\r\n        // discard semicolon\r\n        // assignment_statement semicolon\r\n        // compound_statement\r\n        // increment_statement semicolon\r\n        // decrement_statement semicolon\r\n        // static_assert_statement semicolon\r\n\r\n        // Ignore any stand-alone semicolons\r\n        while (this._match(Token.semicolon) && !this._isAtEnd());\r\n\r\n        if (this._check(Keyword.if))\r\n            return this._if_statement();\r\n\r\n        if (this._check(Keyword.switch))\r\n            return this._switch_statement();\r\n\r\n        if (this._check(Keyword.loop))\r\n            return this._loop_statement();\r\n\r\n        if (this._check(Keyword.for))\r\n            return this._for_statement();\r\n\r\n        if (this._check(Keyword.while))\r\n            return this._while_statement();\r\n\r\n        if (this._check(Keyword.static_assert))\r\n            return this._static_assert_statement();\r\n\r\n        if (this._check(Token.brace_left))\r\n            return this._compound_statement();\r\n\r\n        let result = null;\r\n        if (this._check(Keyword.return))\r\n            result = this._return_statement();\r\n        else if (this._check([Keyword.var, Keyword.let, Keyword.const]))\r\n            result = this._variable_statement();\r\n        else if (this._match(Keyword.discard))\r\n            result = new AST(\"discard\");\r\n        else if (this._match(Keyword.break))\r\n            result = new AST(\"break\");\r\n        else if (this._match(Keyword.continue))\r\n            result = new AST(\"continue\");\r\n        else \r\n            result = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();\r\n        \r\n        if (result != null)\r\n            this._consume(Token.semicolon, \"Expected ';' after statement.\");\r\n\r\n        return result;\r\n    }\r\n    \r\n    _static_assert_statement() {\r\n        if (!this._match(Keyword.static_assert))\r\n            return null;\r\n        let expression = this._optional_paren_expression();\r\n        return new AST(\"static_assert\", { expression });\r\n    }\r\n\r\n    _while_statement() {\r\n        if (!this._match(Keyword.while))\r\n            return null;\r\n        let condition = this._optional_paren_expression();\r\n        const block = this._compound_statement();\r\n        return new AST(\"while\", { condition, block });\r\n    }\r\n\r\n    _for_statement() {\r\n        // for paren_left for_header paren_right compound_statement\r\n        if (!this._match(Keyword.for))\r\n            return null;\r\n\r\n        this._consume(Token.paren_left, \"Expected '('.\");\r\n\r\n        // for_header: (variable_statement assignment_statement func_call_statement)? semicolon short_circuit_or_expression? semicolon (assignment_statement func_call_statement)?\r\n        const init = !this._check(Token.semicolon) ? this._for_init() : null;\r\n        this._consume(Token.semicolon, \"Expected ';'.\");\r\n        const condition = !this._check(Token.semicolon) ? this._short_circuit_or_expression() : null;\r\n        this._consume(Token.semicolon, \"Expected ';'.\");\r\n        const increment = !this._check(Token.paren_right) ? this._for_increment() : null;\r\n\r\n        this._consume(Token.paren_right, \"Expected ')'.\");\r\n\r\n        const body = this._compound_statement();\r\n\r\n        return new AST(\"for\", { init, condition, increment, body });\r\n    }\r\n\r\n    _for_init() {\r\n        // (variable_statement assignment_statement func_call_statement)?\r\n        return this._variable_statement() || this._func_call_statement() || this._assignment_statement();\r\n    }\r\n\r\n    _for_increment() {\r\n        // (assignment_statement func_call_statement increment_statement)?\r\n        return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();\r\n    }\r\n\r\n    _variable_statement() {\r\n        // variable_decl\r\n        // variable_decl equal short_circuit_or_expression\r\n        // let (ident variable_ident_decl) equal short_circuit_or_expression\r\n        // const (ident variable_ident_decl) equal short_circuit_or_expression\r\n        if (this._check(Keyword.var)) {\r\n            const _var = this._variable_decl();\r\n            let value = null;\r\n            if (this._match(Token.equal))\r\n                value = this._short_circuit_or_expression();\r\n\r\n            return new AST(\"var\", { var: _var, value });\r\n        }\r\n\r\n        if (this._match(Keyword.let)) {\r\n            const name = this._consume(Token.ident, \"Expected name for let.\").toString();\r\n            let type = null;\r\n            if (this._match(Token.colon)) {\r\n                const typeAttrs = this._attribute();\r\n                type = this._type_decl();\r\n                type.attributes = typeAttrs;\r\n            }\r\n            this._consume(Token.equal, \"Expected '=' for let.\");\r\n            const value = this._short_circuit_or_expression();\r\n            return new AST(\"let\", { name, type, value });\r\n        }\r\n\r\n        if (this._match(Keyword.const)) {\r\n            const name = this._consume(Token.ident, \"Expected name for const.\").toString();\r\n            let type = null;\r\n            if (this._match(Token.colon)) {\r\n                const typeAttrs = this._attribute();\r\n                type = this._type_decl();\r\n                type.attributes = typeAttrs;\r\n            }\r\n            this._consume(Token.equal, \"Expected '=' for const.\");\r\n            const value = this._short_circuit_or_expression();\r\n            return new AST(\"const\", { name, type, value });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _increment_decrement_statement() {\r\n        const savedPos = this._current;\r\n\r\n        const _var = this._unary_expression();\r\n        if (_var == null)\r\n            return null;\r\n\r\n        if (!this._check(Token.increment_operators)) {\r\n            this._current = savedPos;\r\n            return null;\r\n        }\r\n\r\n        const type = this._consume(Token.increment_operators, \"Expected increment operator\");\r\n\r\n        return new AST(\"increment\", { type, var: _var });\r\n    }\r\n\r\n    _assignment_statement() {\r\n        // (unary_expression underscore) equal short_circuit_or_expression\r\n        let _var = null;\r\n\r\n        if (this._check(Token.brace_right))\r\n            return null;\r\n\r\n        let isUnderscore = this._match(Token.underscore);\r\n        if (!isUnderscore)\r\n            _var = this._unary_expression();\r\n\r\n        if (!isUnderscore && _var == null)\r\n            return null;\r\n\r\n        const type = this._consume(Token.assignment_operators, \"Expected assignment operator.\");\r\n\r\n        const value = this._short_circuit_or_expression();\r\n\r\n        return new AST(\"assign\", { type, var: _var, value });\r\n    }\r\n\r\n    _func_call_statement() {\r\n        // ident argument_expression_list\r\n        if (!this._check(Token.ident))\r\n            return null;\r\n\r\n        const savedPos = this._current;\r\n        const name = this._consume(Token.ident, \"Expected function name.\");\r\n        const args = this._argument_expression_list();\r\n\r\n        if (args === null) {\r\n            this._current = savedPos;\r\n            return null;\r\n        }\r\n\r\n        return new AST(\"call\", { name, args });\r\n    }\r\n\r\n    _loop_statement() {\r\n        // loop brace_left statement* continuing_statement? brace_right\r\n        if (!this._match(Keyword.loop))\r\n            return null;\r\n\r\n        this._consume(Token.brace_left, \"Expected '{' for loop.\");\r\n\r\n        // statement*\r\n        const statements = [];\r\n        let statement = this._statement();\r\n        while (statement !== null) {\r\n            statements.push(statement);\r\n            statement = this._statement();\r\n        }\r\n\r\n        // continuing_statement: continuing compound_statement\r\n        let continuing = null;\r\n        if (this._match(Keyword.continuing))\r\n            continuing = this._compound_statement();\r\n\r\n        this._consume(Token.brace_right, \"Expected '}' for loop.\");\r\n\r\n        return new AST(\"loop\", { statements, continuing });\r\n    }\r\n\r\n    _switch_statement() {\r\n        // switch optional_paren_expression brace_left switch_body+ brace_right\r\n        if (!this._match(Keyword.switch))\r\n            return null;\r\n\r\n        const condition = this._optional_paren_expression();\r\n        this._consume(Token.brace_left);\r\n        const body = this._switch_body();\r\n        if (body == null || body.length == 0)\r\n            throw this._error(this._previous(), \"Expected 'case' or 'default'.\");\r\n        this._consume(Token.brace_right);\r\n        return new AST(\"switch\", { condition, body });\r\n    }\r\n\r\n    _switch_body() {\r\n        // case case_selectors colon brace_left case_body? brace_right\r\n        // default colon brace_left case_body? brace_right\r\n        const cases = [];\r\n        if (this._match(Keyword.case)) {\r\n            this._consume(Keyword.case);\r\n            const selector = this._case_selectors();\r\n            this._consume(Token.colon, \"Exected ':' for switch case.\");\r\n            this._consume(Token.brace_left, \"Exected '{' for switch case.\");\r\n            const body = this._case_body();\r\n            this._consume(Token.brace_right, \"Exected '}' for switch case.\");\r\n            cases.push(new AST(\"case\", { selector, body }));\r\n        }\r\n\r\n        if (this._match(Keyword.default)) {\r\n            this._consume(Token.colon, \"Exected ':' for switch default.\");\r\n            this._consume(Token.brace_left, \"Exected '{' for switch default.\");\r\n            const body = this._case_body();\r\n            this._consume(Token.brace_right, \"Exected '}' for switch default.\");\r\n            cases.push(new AST(\"default\", { body }));\r\n        }\r\n\r\n        if (this._check([Keyword.default, Keyword.case])) {\r\n            const _cases = this._switch_body();\r\n            cases.push(_cases[0]);\r\n        }\r\n\r\n        return cases;\r\n    }\r\n\r\n    _case_selectors() {\r\n        // const_literal (comma const_literal)* comma?\r\n        const selectors = [this._consume(Token.const_literal, \"Expected constant literal\").toString()];\r\n        while (this._match(Token.comma)) {\r\n            selectors.push(this._consume(Token.const_literal, \"Expected constant literal\").toString());\r\n        }\r\n        return selectors;\r\n    }\r\n\r\n    _case_body() {\r\n        // statement case_body?\r\n        // fallthrough semicolon\r\n        if (this._match(Keyword.fallthrough)) {\r\n            this._consume(Token.semicolon);\r\n            return [];\r\n        }\r\n\r\n        const statement = this._statement();\r\n        if (statement == null)\r\n            return [];\r\n\r\n        const nextStatement = this._case_body();\r\n        if (nextStatement.length == 0)\r\n            return [statement];\r\n\r\n        return [statement, nextStatement[0]];\r\n    }\r\n\r\n    _if_statement() {\r\n        // if optional_paren_expression compound_statement elseif_statement? else_statement?\r\n        if (!this._match(Keyword.if))\r\n            return null;\r\n\r\n        const condition = this._optional_paren_expression();\r\n        const block = this._compound_statement();\r\n\r\n        let elseif = null;\r\n        if (this._match(Keyword.elseif))\r\n            elseif = this._elseif_statement();\r\n\r\n        let _else = null;\r\n        if (this._match(Keyword.else))\r\n            _else = this._compound_statement();\r\n\r\n        return new AST(\"if\", { condition, block, elseif, else: _else });\r\n    }\r\n\r\n    _elseif_statement() {\r\n        // else_if optional_paren_expression compound_statement elseif_statement?\r\n        const elseif = [];\r\n        const condition = this._optional_paren_expression();\r\n        const block = this._compound_statement();\r\n        elseif.push(new AST(\"elseif\", { condition, block }));\r\n        if (this._match(Keyword.elseif))\r\n            elseif.push(this._elseif_statement()[0]);\r\n        return elseif;\r\n    }\r\n\r\n    _return_statement() {\r\n        // return short_circuit_or_expression?\r\n        if (!this._match(Keyword.return))\r\n            return null;\r\n        const value = this._short_circuit_or_expression();\r\n        return new AST(\"return\", { value: value });\r\n    }\r\n\r\n    _short_circuit_or_expression() {\r\n        // short_circuit_and_expression\r\n        // short_circuit_or_expression or_or short_circuit_and_expression\r\n        let expr = this._short_circuit_and_expr();\r\n        while (this._match(Token.or_or)) {\r\n            expr = new AST(\"compareOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._short_circuit_and_expr()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _short_circuit_and_expr() {\r\n        // inclusive_or_expression\r\n        // short_circuit_and_expression and_and inclusive_or_expression\r\n        let expr = this._inclusive_or_expression();\r\n        while (this._match(Token.and_and)) {\r\n            expr = new AST(\"compareOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._inclusive_or_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _inclusive_or_expression() {\r\n        // exclusive_or_expression\r\n        // inclusive_or_expression or exclusive_or_expression\r\n        let expr = this._exclusive_or_expression();\r\n        while (this._match(Token.or)) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._exclusive_or_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _exclusive_or_expression() {\r\n        // and_expression\r\n        // exclusive_or_expression xor and_expression\r\n        let expr = this._and_expression();\r\n        while (this._match(Token.xor)) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._and_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _and_expression() {\r\n        // equality_expression\r\n        // and_expression and equality_expression\r\n        let expr = this._equality_expression();\r\n        while (this._match(Token.and)) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._equality_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n    \r\n    _equality_expression() {\r\n        // relational_expression\r\n        // relational_expression equal_equal relational_expression\r\n        // relational_expression not_equal relational_expression\r\n        const expr = this._relational_expression();\r\n        if (this._match([Token.equal_equal, Token.not_equal])) {\r\n            return new AST(\"compareOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._relational_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _relational_expression() {\r\n        // shift_expression\r\n        // relational_expression less_than shift_expression\r\n        // relational_expression greater_than shift_expression\r\n        // relational_expression less_than_equal shift_expression\r\n        // relational_expression greater_than_equal shift_expression\r\n        let expr = this._shift_expression();\r\n        while (this._match([Token.less_than, Token.greater_than, Token.less_than_equal,\r\n                            Token.greater_than_equal])) {\r\n            expr = new AST(\"compareOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._shift_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _shift_expression() {\r\n        // additive_expression\r\n        // shift_expression shift_left additive_expression\r\n        // shift_expression shift_right additive_expression\r\n        let expr = this._additive_expression();\r\n        while (this._match([Token.shift_left, Token.shift_right])) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._additive_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _additive_expression() {\r\n        // multiplicative_expression\r\n        // additive_expression plus multiplicative_expression\r\n        // additive_expression minus multiplicative_expression\r\n        let expr = this._multiplicative_expression();\r\n        while (this._match([Token.plus, Token.minus])) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._multiplicative_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _multiplicative_expression() {\r\n        // unary_expression\r\n        // multiplicative_expression star unary_expression\r\n        // multiplicative_expression forward_slash unary_expression\r\n        // multiplicative_expression modulo unary_expression\r\n        let expr = this._unary_expression();\r\n        while (this._match([Token.star, Token.forward_slash, Token.modulo])) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._unary_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _unary_expression() {\r\n        // singular_expression\r\n        // minus unary_expression\r\n        // bang unary_expression\r\n        // tilde unary_expression\r\n        // star unary_expression\r\n        // and unary_expression\r\n        if (this._match([Token.minus, Token.bang, Token.tilde, Token.star, Token.and])) {\r\n            return new AST(\"unaryOp\", {\r\n                operator: this._previous().toString(), right: this._unary_expression() });\r\n        }\r\n        return this._singular_expression();\r\n    }\r\n\r\n    _singular_expression() {\r\n        // primary_expression postfix_expression ?\r\n        const expr = this._primary_expression();\r\n        const p = this._postfix_expression();\r\n        if (p)\r\n            expr.postfix = p;\r\n        return expr;\r\n    }\r\n\r\n    _postfix_expression() {\r\n        // bracket_left short_circuit_or_expression bracket_right postfix_expression?\r\n        if (this._match(Token.bracket_left)) {\r\n            const expr = this._short_circuit_or_expression();\r\n            this._consume(Token.bracket_right, \"Expected ']'.\");\r\n            const p = this._postfix_expression();\r\n            if (p)\r\n                expr.postfix = p;\r\n            return expr;\r\n        }\r\n\r\n        // period ident postfix_expression?\r\n        if (this._match(Token.period)) {\r\n            const name = this._consume(Token.ident, \"Expected member name.\");\r\n            const p = this._postfix_expression();\r\n            if (p)\r\n                name.postfix = p;\r\n            return name;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _primary_expression() {\r\n        // ident argument_expression_list?\r\n        if (this._match(Token.ident)) {\r\n            const name = this._previous().toString();\r\n            if (this._check(Token.paren_left)) {\r\n                const args = this._argument_expression_list();\r\n                return new AST(\"call_expr\", { name, args });\r\n            }\r\n            return new AST(\"variable_expr\", { name });\r\n        }\r\n\r\n        // const_literal\r\n        if (this._match(Token.const_literal)) {\r\n            return new AST(\"literal_expr\", { value: this._previous().toString() });\r\n        }\r\n\r\n        // paren_expression\r\n        if (this._check(Token.paren_left)) {\r\n            return this._paren_expression();\r\n        }\r\n\r\n        // bitcast less_than type_decl greater_than paren_expression\r\n        if (this._match(Keyword.bitcast)) {\r\n            this._consume(Token.less_than, \"Expected '<'.\");\r\n            const type = this._type_decl();\r\n            this._consume(Token.greater_than, \"Expected '>'.\");\r\n            const value = this._paren_expression();\r\n            return new AST(\"bitcast_expr\", { type, value });\r\n        }\r\n\r\n        // type_decl argument_expression_list\r\n        const type = this._type_decl();\r\n        const args = this._argument_expression_list();\r\n        return new AST(\"typecast_expr\", { type, args });\r\n    }\r\n\r\n    _argument_expression_list() {\r\n        // paren_left ((short_circuit_or_expression comma)* short_circuit_or_expression comma?)? paren_right\r\n        if (!this._match(Token.paren_left))\r\n            return null;\r\n\r\n        const args = [];\r\n        do {\r\n            if (this._check(Token.paren_right))\r\n                break;\r\n            const arg = this._short_circuit_or_expression();\r\n            args.push(arg);\r\n        } while (this._match(Token.comma));\r\n        this._consume(Token.paren_right, \"Expected ')' for agument list\");\r\n\r\n        return args;\r\n    }\r\n\r\n    _optional_paren_expression() {\r\n        // [paren_left] short_circuit_or_expression [paren_right]\r\n        this._match(Token.paren_left);\r\n        const expr = this._short_circuit_or_expression();\r\n        this._match(Token.paren_right);\r\n        return new AST(\"grouping_expr\", { contents: expr });\r\n    }\r\n\r\n    _paren_expression() {\r\n        // paren_left short_circuit_or_expression paren_right\r\n        this._consume(Token.paren_left, \"Expected '('.\");\r\n        const expr = this._short_circuit_or_expression();\r\n        this._consume(Token.paren_right, \"Expected ')'.\");\r\n        return new AST(\"grouping_expr\", { contents: expr });\r\n    }\r\n\r\n    _struct_decl() {\r\n        // attribute* struct ident struct_body_decl\r\n        if (!this._match(Keyword.struct))\r\n            return null;\r\n\r\n        const name = this._consume(Token.ident, \"Expected name for struct.\").toString();\r\n\r\n        // struct_body_decl: brace_left (struct_member comma)* struct_member comma? brace_right\r\n        this._consume(Token.brace_left, \"Expected '{' for struct body.\");\r\n        const members = [];\r\n        while (!this._check(Token.brace_right)) {\r\n            // struct_member: attribute* variable_ident_decl\r\n            const memberAttrs = this._attribute();\r\n\r\n            const memberName = this._consume(Token.ident, \"Expected variable name.\").toString();\r\n\r\n            this._consume(Token.colon, \"Expected ':' for struct member type.\");\r\n\r\n            const typeAttrs = this._attribute();\r\n            const memberType = this._type_decl();\r\n            memberType.attributes = typeAttrs;\r\n            \r\n            if (!this._check(Token.brace_right))\r\n                this._consume(Token.comma, \"Expected ',' for struct member.\");\r\n            else\r\n                this._match(Token.comma); // trailing comma optional.\r\n\r\n            members.push(new AST(\"member\", {\r\n                name: memberName,\r\n                attributes: memberAttrs,\r\n                type: memberType\r\n            }));\r\n        }\r\n\r\n        this._consume(Token.brace_right, \"Expected '}' after struct body.\");\r\n\r\n        return new AST(\"struct\", { name, members });\r\n    }\r\n\r\n    _global_variable_decl() {\r\n        // attribute* variable_decl (equal const_expression)?\r\n        const _var = this._variable_decl();\r\n        if (this._match(Token.equal))\r\n            _var.value = this._const_expression();\r\n        return _var;\r\n    }\r\n\r\n    _global_constant_decl() {\r\n        // attribute* let (ident variable_ident_decl) global_const_initializer?\r\n        if (!this._match(Keyword.let))\r\n            return null;\r\n\r\n        const name = this._consume(Token.ident, \"Expected variable name\");\r\n        let type = null;\r\n        if (this._match(Token.colon)) {\r\n            const attrs = this._attribute();\r\n            type = this._type_decl();\r\n            type.attributes = attrs;\r\n        }\r\n        let value = null;\r\n        if (this._match(Token.equal)) {\r\n            value = this._const_expression();\r\n        }\r\n        return new AST(\"let\", { name: name.toString(), type, value });\r\n    }\r\n\r\n    _const_expression() {\r\n        // type_decl paren_left ((const_expression comma)* const_expression comma?)? paren_right\r\n        // const_literal\r\n        if (this._match(Token.const_literal))\r\n            return this._previous().toString();\r\n        \r\n        const type = this._type_decl();\r\n\r\n        this._consume(Token.paren_left, \"Expected '('.\");\r\n\r\n        let args = [];\r\n        while (!this._check(Token.paren_right)) {\r\n            args.push(this._const_expression());\r\n            if (!this._check(Token.comma))\r\n                break;\r\n            this._advance();\r\n        }\r\n\r\n        this._consume(Token.paren_right, \"Expected ')'.\");\r\n\r\n        return new AST(\"create\", { type, args });\r\n    }\r\n\r\n    _variable_decl() {\r\n        // var variable_qualifier? (ident variable_ident_decl)\r\n        if (!this._match(Keyword.var))\r\n            return null;\r\n\r\n        // variable_qualifier: less_than storage_class (comma access_mode)? greater_than\r\n        let storage = null;\r\n        let access = null;\r\n        if (this._match(Token.less_than)) {\r\n            storage = this._consume(Token.storage_class, \"Expected storage_class.\").toString();\r\n            if (this._match(Token.comma))\r\n                access = this._consume(Token.access_mode, \"Expected access_mode.\").toString();\r\n            this._consume(Token.greater_than, \"Expected '>'.\");\r\n        }\r\n\r\n        const name = this._consume(Token.ident, \"Expected variable name\");\r\n        let type = null;\r\n        if (this._match(Token.colon)) {\r\n            const attrs = this._attribute();\r\n            type = this._type_decl();\r\n            type.attributes = attrs;\r\n        }\r\n\r\n        return new AST(\"var\", { name: name.toString(), type, storage, access });\r\n    }\r\n\r\n    _enable_directive() {\r\n        // enable ident semicolon\r\n        const name = this._consume(Token.ident, \"identity expected.\");\r\n        return new AST(\"enable\", { name: name.toString() });\r\n    }\r\n\r\n    _type_alias() {\r\n        // type ident equal type_decl\r\n        const name = this._consume(Token.ident, \"identity expected.\");\r\n        this._consume(Token.equal, \"Expected '=' for type alias.\");\r\n        const alias = this._type_decl();\r\n        return new AST(\"alias\", { name: name.toString(), alias });\r\n    }\r\n\r\n    _type_decl() {\r\n        // ident\r\n        // bool\r\n        // float32\r\n        // int32\r\n        // uint32\r\n        // vec2 less_than type_decl greater_than\r\n        // vec3 less_than type_decl greater_than\r\n        // vec4 less_than type_decl greater_than\r\n        // mat2x2 less_than type_decl greater_than\r\n        // mat2x3 less_than type_decl greater_than\r\n        // mat2x4 less_than type_decl greater_than\r\n        // mat3x2 less_than type_decl greater_than\r\n        // mat3x3 less_than type_decl greater_than\r\n        // mat3x4 less_than type_decl greater_than\r\n        // mat4x2 less_than type_decl greater_than\r\n        // mat4x3 less_than type_decl greater_than\r\n        // mat4x4 less_than type_decl greater_than\r\n        // atomic less_than type_decl greater_than\r\n        // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n        // array_type_decl\r\n        // texture_sampler_types\r\n\r\n        if (this._check([Token.ident, ...Token.texel_format, Keyword.bool, Keyword.float32, Keyword.int32, Keyword.uint32])) {\r\n            const type = this._advance();\r\n            return new AST(\"type\", { name: type.toString() });\r\n        }\r\n        \r\n        if (this._check(Token.template_types)) {\r\n            let type = this._advance().toString();\r\n            let format = null;\r\n            let access = null;\r\n            if (this._match(Token.less_than)) {\r\n                format = this._type_decl();\r\n                access = null;\r\n                if (this._match(Token.comma))\r\n                    access = this._consume(Token.access_mode, \"Expected access_mode for pointer\").toString();\r\n                this._consume(Token.greater_than, \"Expected '>' for type.\");\r\n            }\r\n            return new AST(type, { name: type, format, access });\r\n        }\r\n\r\n        // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n        if (this._match(Keyword.pointer)) {\r\n            let pointer = this._previous().toString();\r\n            this._consume(Token.less_than, \"Expected '<' for pointer.\");\r\n            const storage = this._consume(Token.storage_class, \"Expected storage_class for pointer\");\r\n            this._consume(Token.comma, \"Expected ',' for pointer.\");\r\n            const decl = this._type_decl();\r\n            let access = null;\r\n            if (this._match(Token.comma))\r\n                access = this._consume(Token.access_mode, \"Expected access_mode for pointer\").toString();\r\n            this._consume(Token.greater_than, \"Expected '>' for pointer.\");\r\n            return new AST(\"pointer\", { name: pointer, storage: storage.toString(), decl, access });\r\n        }\r\n\r\n        // texture_sampler_types\r\n        let type = this._texture_sampler_types();\r\n        if (type)\r\n            return type;\r\n\r\n        // The following type_decl's have an optional attribyte_list*\r\n        const attrs = this._attribute();\r\n\r\n        // attribute* array less_than type_decl (comma element_count_expression)? greater_than\r\n        if (this._match(Keyword.array)) {\r\n            const array = this._previous();\r\n            this._consume(Token.less_than, \"Expected '<' for array type.\");\r\n            const format = this._type_decl();\r\n            let count = null;\r\n            if (this._match(Token.comma))\r\n                count = this._consume(Token.element_count_expression, \"Expected element_count for array.\").toString();\r\n            this._consume(Token.greater_than, \"Expected '>' for array.\");\r\n\r\n            return new AST(\"array\", { name: array.toString(), attributes: attrs, format, count });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _texture_sampler_types() {\r\n        // sampler_type\r\n        if (this._match(Token.sampler_type))\r\n            return new AST(\"sampler\", { name: this._previous().toString() });\r\n\r\n        // depth_texture_type\r\n        if (this._match(Token.depth_texture_type))\r\n            return new AST(\"sampler\", { name: this._previous().toString() });\r\n\r\n        // sampled_texture_type less_than type_decl greater_than\r\n        // multisampled_texture_type less_than type_decl greater_than\r\n        if (this._match(Token.sampled_texture_type) || \r\n            this._match(Token.multisampled_texture_type)) {\r\n            const sampler = this._previous();\r\n            this._consume(Token.less_than, \"Expected '<' for sampler type.\");\r\n            const format = this._type_decl();\r\n            this._consume(Token.greater_than, \"Expected '>' for sampler type.\");\r\n            return new AST(\"sampler\", { name: sampler.toString(), format });\r\n        }\r\n\r\n        // storage_texture_type less_than texel_format comma access_mode greater_than\r\n        if (this._match(Token.storage_texture_type)) {\r\n            const sampler = this._previous();\r\n            this._consume(Token.less_than, \"Expected '<' for sampler type.\");\r\n            const format = this._consume(Token.texel_format, \"Invalid texel format.\").toString();\r\n            this._consume(Token.comma, \"Expected ',' after texel format.\");\r\n            const access = this._consume(Token.access_mode, \"Expected access mode for storage texture type.\").toString();\r\n            this._consume(Token.greater_than, \"Expected '>' for sampler type.\");\r\n            return new AST(\"sampler\", { name: sampler.toString(), format, access });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _attribute() {\r\n        // attr ident paren_left (literal_or_ident comma)* literal_or_ident paren_right\r\n        // attr ident\r\n\r\n        let attributes = [];\r\n\r\n        while (this._match(Token.attr))\r\n        {\r\n            const name = this._consume(Token.attribute_name, \"Expected attribute name\");\r\n            const attr = new AST(\"attribute\", { name: name.toString() });\r\n            if (this._match(Token.paren_left)) {\r\n                // literal_or_ident\r\n                attr.value = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                if (this._check(Token.comma)) {\r\n                    this._advance();\r\n                    attr.value = [attr.value];\r\n                    do {\r\n                        const v = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                        attr.value.push(v);\r\n                    } while (this._match(Token.comma));\r\n                }\r\n                this._consume(Token.paren_right, \"Expected ')'\");\r\n            }\r\n            attributes.push(attr);\r\n        }\r\n\r\n        // Deprecated:\r\n        // attr_left (attribute comma)* attribute attr_right\r\n        while (this._match(Token.attr_left)) {\r\n            if (!this._check(Token.attr_right)) {\r\n                do {\r\n                    const name = this._consume(Token.attribute_name, \"Expected attribute name\");\r\n                    const attr = new AST(\"attribute\", { name: name.toString() });\r\n                    if (this._match(Token.paren_left)) {\r\n                        // literal_or_ident\r\n                        attr.value = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                        if (this._check(Token.comma)) {\r\n                            this._advance();\r\n                            attr.value = [attr.value];\r\n                            do {\r\n                                const v = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                                attr.value.push(v);\r\n                            } while (this._match(Token.comma));\r\n                        }\r\n                        this._consume(Token.paren_right, \"Expected ')'\");\r\n                    }\r\n                    attributes.push(attr);\r\n                } while (this._match(Token.comma));\r\n\r\n            }\r\n            // Consume ]]\r\n            this._consume(Token.attr_right, \"Expected ']]' after attribute declarations\");\r\n        }\r\n\r\n        if (attributes.length == 0)\r\n            return null;\r\n\r\n        return attributes;\r\n    }\r\n}\r\n\r\n/**\r\n * @author Brendan Duncan / https://github.com/brendan-duncan\r\n */\r\n\r\nclass WgslReflect {\r\n    constructor(code) {\r\n        if (code)\r\n            this.initialize(code);\r\n    }\r\n\r\n    initialize(code) {\r\n        const parser = new WgslParser();\r\n        this.ast = parser.parse(code);\r\n\r\n        // All top-level structs in the shader.\r\n        this.structs = [];\r\n        // All top-level uniform vars in the shader.\r\n        this.uniforms = [];\r\n        // All top-level storage vars in the shader.\r\n        this.storage = [];\r\n        // All top-level texture vars in the shader;\r\n        this.textures = [];\r\n        // All top-level sampler vars in the shader.\r\n        this.samplers = [];\r\n        // All top-level functions in the shader.\r\n        this.functions = [];\r\n        // All top-level type aliases in the shader.\r\n        this.aliases = [];\r\n        // All entry functions in the shader: vertex, fragment, and/or compute.\r\n        this.entry = {\r\n            vertex: [],\r\n            fragment: [],\r\n            compute: []\r\n        };\r\n\r\n        for (const node of this.ast) {\r\n            if (node._type == \"struct\")\r\n                this.structs.push(node);\r\n\r\n            if (node._type == \"alias\")\r\n                this.aliases.push(node);\r\n\r\n            if (this.isUniformVar(node)) {\r\n                const group = this.getAttribute(node, \"group\");\r\n                node.group = group && group.value ? parseInt(group.value) : 0;\r\n                const binding = this.getAttribute(node, \"binding\");\r\n                node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                this.uniforms.push(node);\r\n            }\r\n\r\n            if (this.isStorageVar(node)) {\r\n                const group = this.getAttribute(node, \"group\");\r\n                node.group = group && group.value ? parseInt(group.value) : 0;\r\n                const binding = this.getAttribute(node, \"binding\");\r\n                node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                this.storage.push(node);\r\n            }\r\n\r\n            if (this.isTextureVar(node)) {\r\n                const group = this.getAttribute(node, \"group\");\r\n                node.group = group && group.value ? parseInt(group.value) : 0;\r\n                const binding = this.getAttribute(node, \"binding\");\r\n                node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                this.textures.push(node);\r\n            }\r\n\r\n            if (this.isSamplerVar(node)) {\r\n                const group = this.getAttribute(node, \"group\");\r\n                node.group = group && group.value ? parseInt(group.value) : 0;\r\n                const binding = this.getAttribute(node, \"binding\");\r\n                node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                this.samplers.push(node);\r\n            }\r\n\r\n            if (node._type == \"function\") {\r\n                this.functions.push(node);\r\n                const vertexStage = this.getAttribute(node, \"vertex\");\r\n                const fragmentStage = this.getAttribute(node, \"fragment\");\r\n                const computeStage = this.getAttribute(node, \"compute\");\r\n                const stage = vertexStage || fragmentStage || computeStage;\r\n                if (stage) {\r\n                    node.inputs = this._getInputs(node);\r\n                    if (this.entry[stage.name])\r\n                        this.entry[stage.name].push(node);\r\n                    else\r\n                        this.entry[stage.name] = [node];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    isTextureVar(node) {\r\n        return node._type == \"var\" && WgslReflect.TextureTypes.indexOf(node.type.name) != -1;\r\n    }\r\n\r\n    isSamplerVar(node) {\r\n        return node._type == \"var\" && WgslReflect.SamplerTypes.indexOf(node.type.name) != -1;\r\n    }\r\n\r\n    isUniformVar(node) {\r\n        return node && node._type == \"var\" && node.storage == \"uniform\";\r\n    }\r\n\r\n    isStorageVar(node) {\r\n        return node && node._type == \"var\" && node.storage == \"storage\";\r\n    }\r\n\r\n    _getInputs(args, inputs) {\r\n        if (args._type == \"function\")\r\n            args = args.args;\r\n        if (!inputs)\r\n            inputs = [];\r\n\r\n        for (const arg of args) {\r\n            const input = this._getInputInfo(arg);\r\n            if (input)\r\n                inputs.push(input);\r\n            const struct = this.getStruct(arg.type);\r\n            if (struct)\r\n                this._getInputs(struct.members, inputs);\r\n        }\r\n\r\n        return inputs;\r\n    }\r\n\r\n    _getInputInfo(node) {\r\n        const location = this.getAttribute(node, \"location\") || this.getAttribute(node, \"builtin\");\r\n        if (location) {\r\n            let input = {\r\n                name: node.name,\r\n                type: node.type,\r\n                input: node,\r\n                locationType: location.name,\r\n                location: this._parseInt(location.value)\r\n            };\r\n            const interpolation = this.getAttribute(node, \"interpolation\");\r\n            if (interpolation)\r\n                input.interpolation = interpolation.value;\r\n            return input;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _parseInt(s) {\r\n        const n = parseInt(s);\r\n        return isNaN(n) ? s : n;\r\n    }\r\n\r\n    getAlias(name) {\r\n        if (!name) return null;\r\n        if (name.constructor === AST) {\r\n            if (name._type != \"type\")\r\n                return null;\r\n            name = name.name;\r\n        }\r\n        for (const u of this.aliases) {\r\n            if (u.name == name)\r\n                return u.alias;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getStruct(name) {\r\n        if (!name) return null;\r\n        if (name.constructor === AST) {\r\n            if (name._type == \"struct\")\r\n                return name;\r\n            if (name._type != \"type\")\r\n                return null;\r\n            name = name.name;\r\n        }\r\n        for (const u of this.structs) {\r\n            if (u.name == name)\r\n                return u;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getAttribute(node, name) {\r\n        if (!node || !node.attributes) return null;\r\n        for (let a of node.attributes) {\r\n            if (a.name == name)\r\n                return a;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getBindGroups() {\r\n        const groups = [];\r\n\r\n        function _makeRoom(group, binding) {\r\n            if (group >= groups.length)\r\n                groups.length = group + 1;\r\n            if (groups[group] === undefined)\r\n                groups[group] = [];\r\n\r\n            if (binding >= groups[group].length)\r\n                groups[group].length = binding + 1;\r\n        }\r\n\r\n        for (const u of this.uniforms) {\r\n            _makeRoom(u.group, u.binding);\r\n            const group = groups[u.group];\r\n            group[u.binding] = { type: 'buffer', resource: this.getUniformBufferInfo(u) };\r\n        }\r\n        \r\n        for (const u of this.storage) {\r\n            _makeRoom(u.group, u.binding);\r\n            const group = groups[u.group];\r\n            group[u.binding] = { type: 'storage', resource: this.getStorageBufferInfo(u) };\r\n        }\r\n\r\n        for (const t of this.textures) {\r\n            _makeRoom(t.group, t.binding);\r\n            const group = groups[t.group];\r\n            group[t.binding] = { type: 'texture', resource: t };\r\n        }\r\n\r\n        for (const t of this.samplers) {\r\n            _makeRoom(t.group, t.binding);\r\n            const group = groups[t.group];\r\n            group[t.binding] = { type: 'sampler', resource: t };\r\n        }\r\n\r\n        return groups;\r\n    }\r\n\r\n    getStorageBufferInfo(node) {\r\n        if (!this.isStorageVar(node))\r\n            return null;\r\n\r\n        let group = this.getAttribute(node, \"group\");\r\n        let binding = this.getAttribute(node, \"binding\");\r\n\r\n        group = group && group.value ? parseInt(group.value) : 0;\r\n        binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n\r\n        let info = this._getUniformInfo(node);\r\n\r\n        return {\r\n            ...info,\r\n            group,\r\n            binding,\r\n        }\r\n    }\r\n\r\n    /// Returns information about a struct type, null if the type is not a struct.\r\n    /// {\r\n    ///     name: String,\r\n    ///     type: Object,\r\n    ///     align: Int,\r\n    ///     size: Int,\r\n    ///     members: Array,\r\n    ///     isArray: Bool\r\n    ///     isStruct: Bool\r\n    /// }\r\n    getStructInfo(node) {\r\n        if (!node)\r\n            return null;\r\n \r\n        const struct = node._type === 'struct' ? node : this.getStruct(node.type);\r\n        if (!struct)\r\n            return null;\r\n\r\n        let offset = 0;\r\n        let lastSize = 0;\r\n        let lastOffset = 0;\r\n        let structAlign = 0;\r\n        let buffer = { name: node.name, type: node.type, align: 0, size: 0, members: [] };\r\n\r\n        for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {\r\n            let member = struct.members[mi];\r\n            let name = member.name;\r\n\r\n            let info = this.getTypeInfo(member);\r\n            if (!info)\r\n                continue;\r\n\r\n            let type = member.type;\r\n            let align = info.align;\r\n            let size = info.size;\r\n            offset = this._roundUp(align, offset + lastSize);\r\n            lastSize = size;\r\n            lastOffset = offset;\r\n            structAlign = Math.max(structAlign, align);\r\n            let isArray = member.type._type === \"array\";\r\n            let s = this.getStruct(type) || (isArray ? this.getStruct(member.type.format.name) : null);\r\n            let isStruct = !!s;\r\n            let si = isStruct ? this.getStructInfo(s) : undefined;\r\n            let arrayStride = si?.size ?? isArray ? this.getTypeInfo(member.type.format)?.size : this.getTypeInfo(member.type)?.size;\r\n            \r\n            let arrayCount = parseInt(member.type.count ?? 0);\r\n            let members = isStruct ? si?.members : undefined;\r\n\r\n            let u = { name, offset, size, type, member, isArray, arrayCount, arrayStride, isStruct, members };\r\n            buffer.members.push(u);\r\n        }\r\n\r\n        buffer.size = this._roundUp(structAlign, lastOffset + lastSize);\r\n        buffer.align = structAlign;\r\n        buffer.isArray = false;\r\n        buffer.isStruct = true;\r\n        buffer.arrayCount = 0;\r\n\r\n        return buffer;\r\n    }\r\n\r\n    _getUniformInfo(node) {\r\n        let info = this.getStructInfo(node);\r\n        if (info)\r\n            return info;\r\n\r\n        info = this.getTypeInfo(node.type);\r\n        if (!info)\r\n            return info;\r\n\r\n        let s = this.getStruct(node.type.format?.name);\r\n        let si = s ? this.getStructInfo(s) : undefined;\r\n\r\n        info.isArray = node.type._type === \"array\";\r\n        info.isStruct = !!s;\r\n                \r\n        info.members = info.isStruct ? si?.members : undefined;\r\n        info.name = node.name;\r\n        info.type = node.type;\r\n        info.arrayStride = si?.size ?? info.isArray ?\r\n            this.getTypeInfo(node.type.format)?.size :\r\n            this.getTypeInfo(node.type)?.size;\r\n        info.arrayCount = parseInt(node.type.count ?? 0);\r\n        return info;\r\n    }\r\n\r\n    getUniformBufferInfo(node) {\r\n        if (!this.isUniformVar(node))\r\n            return null;\r\n\r\n        let group = this.getAttribute(node, \"group\");\r\n        let binding = this.getAttribute(node, \"binding\");\r\n\r\n        group = group && group.value ? parseInt(group.value) : 0;\r\n        binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n\r\n        let info = this._getUniformInfo(node);\r\n\r\n        return {\r\n            ...info,\r\n            group,\r\n            binding,\r\n        }\r\n    }\r\n\r\n    getTypeInfo(type) {\r\n        if (!type)\r\n            return undefined;\r\n\r\n        let explicitSize = 0;\r\n        const sizeAttr = this.getAttribute(type, \"size\");\r\n        if (sizeAttr)\r\n            explicitSize = parseInt(sizeAttr.value);\r\n\r\n        let explicitAlign = 0;\r\n        const alignAttr = this.getAttribute(type, \"align\");\r\n        if (alignAttr)\r\n            explicitAlign = parseInt(alignAttr.value);\r\n\r\n        if (type._type == \"member\")\r\n            type = type.type;\r\n\r\n        if (type._type == \"type\") {\r\n            const alias = this.getAlias(type.name);\r\n            if (alias) {\r\n                type = alias;\r\n            } else {\r\n                const struct = this.getStruct(type.name);\r\n                if (struct)\r\n                    type = struct;\r\n            }\r\n        }\r\n\r\n        const info = WgslReflect.TypeInfo[type.name];\r\n        if (info) {\r\n            return {\r\n                align: Math.max(explicitAlign, info.align),\r\n                size: Math.max(explicitSize, info.size)\r\n            };\r\n        }\r\n        \r\n        if (type.name == \"array\") {\r\n            let align = 8;\r\n            let size = 8;\r\n            // Type                 AlignOf(T)          Sizeof(T)\r\n            // array<E, N>          AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))\r\n            // array<E>             AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))  (N determined at runtime)\r\n            //\r\n            // @stride(Q)\r\n            // array<E, N>          AlignOf(E)          N * Q\r\n            //\r\n            // @stride(Q)\r\n            // array<E>             AlignOf(E)          Nruntime * Q\r\n            //const E = type.format.name;\r\n            const E = this.getTypeInfo(type.format);\r\n            if (E) {\r\n                size = E.size;\r\n                align = E.align;\r\n            }\r\n\r\n            const N = parseInt(type.count || 1);\r\n\r\n            const stride = this.getAttribute(type, \"stride\");\r\n            if (stride)\r\n                size = N * parseInt(stride.value);\r\n            else\r\n                size = N * this._roundUp(align, size);\r\n\r\n            if (explicitSize)\r\n                size = explicitSize;\r\n\r\n            return {\r\n                align: Math.max(explicitAlign, align),\r\n                size: Math.max(explicitSize, size)\r\n            };\r\n        }\r\n\r\n        if (type._type == \"struct\") {\r\n            let align = 0;\r\n            let size = 0;\r\n            // struct S     AlignOf:    max(AlignOfMember(S, M1), ... , AlignOfMember(S, MN))\r\n            //              SizeOf:     roundUp(AlignOf(S), OffsetOfMember(S, L) + SizeOfMember(S, L))\r\n            //                          Where L is the last member of the structure\r\n            let offset = 0;\r\n            let lastSize = 0;\r\n            let lastOffset = 0;\r\n            for (const m of type.members) {\r\n                const mi = this.getTypeInfo(m);\r\n                align = Math.max(mi.align, align);\r\n                offset = this._roundUp(mi.align, offset + lastSize);\r\n                lastSize = mi.size;\r\n                lastOffset = offset;\r\n            }\r\n            size = this._roundUp(align, lastOffset + lastSize);\r\n\r\n            return {\r\n                align: Math.max(explicitAlign, align),\r\n                size: Math.max(explicitSize, size)\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _roundUp(k, n) {\r\n        return Math.ceil(n / k) * k;\r\n    }\r\n}\r\n\r\n\r\n// Type                 AlignOf(T)          Sizeof(T)\r\n// i32, u32, or f32     4                   4\r\n// atomic<T>            4                   4\r\n// vec2<T>              8                   8\r\n// vec3<T>              16                  12\r\n// vec4<T>              16                  16\r\n// mat2x2<f32>          8                   16\r\n// mat3x2<f32>          8                   24\r\n// mat4x2<f32>          8                   32\r\n// mat2x3<f32>          16                  32\r\n// mat3x3<f32>          16                  48\r\n// mat4x3<f32>          16                  64\r\n// mat2x4<f32>          16                  32\r\n// mat3x4<f32>          16                  48\r\n// mat4x4<f32>          16                  64\r\nWgslReflect.TypeInfo = {\r\n    \"i32\": { align: 4, size: 4 },\r\n    \"u32\": { align: 4, size: 4 },\r\n    \"f32\": { align: 4, size: 4 },\r\n    \"atomic\": { align: 4, size: 4 },\r\n    \"vec2\": { align: 8, size: 8 },\r\n    \"vec3\": { align: 16, size: 12 },\r\n    \"vec4\": { align: 16, size: 16 },\r\n    \"mat2x2\": { align: 8, size: 16 },\r\n    \"mat3x2\": { align: 8, size: 24 },\r\n    \"mat4x2\": { align: 8, size: 32 },\r\n    \"mat2x3\": { align: 16, size: 32 },\r\n    \"mat3x3\": { align: 16, size: 48 },\r\n    \"mat4x3\": { align: 16, size: 64 },\r\n    \"mat2x4\": { align: 16, size: 32 },\r\n    \"mat3x4\": { align: 16, size: 48 },\r\n    \"mat4x4\": { align: 16, size: 64 },\r\n};\r\n\r\nWgslReflect.TextureTypes = Token.any_texture_type.map((t) => { return t.name; });\r\nWgslReflect.SamplerTypes = Token.sampler_type.map((t) => { return t.name; });\r\n\r\nexport { AST, Keyword, Token, WgslParser, WgslReflect, WgslScanner };\r\n","import { WgslReflect, Member } from './3rdParty/wgsl_reflect/wgsl_reflect.module';\n\nexport const roundUpToMultipleOf = (v: number, multiple: number) => (((v + multiple - 1) / multiple) | 0) * multiple;\n\n// TODO: fix better?\nexport const isTypedArray = (arr: any) =>\n    arr && typeof arr.length === 'number' && arr.buffer instanceof ArrayBuffer && typeof arr.byteLength === 'number';\n\nexport type TypedArrayConstructor =\n    | Int8ArrayConstructor\n    | Uint8ArrayConstructor\n    | Int16ArrayConstructor\n    | Uint16ArrayConstructor\n    | Int32ArrayConstructor\n    | Uint32ArrayConstructor\n    | Float32ArrayConstructor\n    | Float64ArrayConstructor;\n\nexport type TypedArray =\n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array;\n\nexport class TypedArrayViewGenerator {\n    arrayBuffer: ArrayBuffer;\n    byteOffset: number;\n\n    constructor(sizeInBytes: number) {\n        this.arrayBuffer = new ArrayBuffer(sizeInBytes);\n        this.byteOffset = 0;\n    }\n    align(alignment: number) {\n        this.byteOffset = roundUpToMultipleOf(this.byteOffset, alignment);\n    }\n    pad(numBytes: number) {\n        this.byteOffset += numBytes;\n    }\n    getView<T extends TypedArray>(Ctor: TypedArrayConstructor, numElements: number): T {\n        const view = new Ctor(this.arrayBuffer, this.byteOffset, numElements);\n        this.byteOffset += view.byteLength;\n        return view as T;\n    }\n}\n\nexport interface StructDefinition {\n    fields: FieldDefinitions;\n    size: number;\n}\n\nexport interface StorageDefinition extends StructDefinition {\n    binding: number;\n    group: number;\n}\n\nexport type IntrinsicDefinition = {\n    offset: number;\n    size: number;\n    type: string;\n    numElements?: number;\n};\n\nexport type FieldDefinition = IntrinsicDefinition | StructDefinition | IntrinsicDefinition[] | StructDefinition[];\n\nexport type FieldDefinitions = {\n    [x: string]: FieldDefinition;\n};\n\n\ntype TypeDef = {\n    numElements: number;\n    align: number;\n    size: number;\n    type: string;\n    View: TypedArrayConstructor;\n};\n\nconst typeInfo: Record<string, TypeDef> = {\n    i32: { numElements: 1, align: 4, size: 4, type: 'i32', View: Int32Array },\n    u32: { numElements: 1, align: 4, size: 4, type: 'u32', View: Uint32Array },\n    f32: { numElements: 1, align: 4, size: 4, type: 'f32', View: Float32Array },\n    f16: { numElements: 1, align: 2, size: 2, type: 'u16', View: Uint16Array },\n    'vec2<i32>': { numElements: 2, align:  8, size:  8, type: 'i32', View: Int32Array },\n    'vec2<u32>': { numElements: 2, align:  8, size:  8, type: 'u32', View: Uint32Array },\n    'vec2<f32>': { numElements: 2, align:  8, size:  8, type: 'f32', View: Float32Array },\n    'vec2': { numElements: 2, align:  8, size:  8, type: 'f32', View: Float32Array },\n    'vec2<f16>': { numElements: 2, align:  4, size:  4, type: 'u16', View: Uint16Array },\n    'vec3<i32>': { numElements: 3, align: 16, size: 12, type: 'i32', View: Int32Array },\n    'vec3<u32>': { numElements: 3, align: 16, size: 12, type: 'u32', View: Uint32Array },\n    'vec3<f32>': { numElements: 3, align: 16, size: 12, type: 'f32', View: Float32Array },\n    'vec3': { numElements: 3, align: 16, size: 12, type: 'f32', View: Float32Array },\n    'vec3<f16>': { numElements: 3, align:  8, size:  6, type: 'u16', View: Uint16Array },\n    'vec4<i32>': { numElements: 4, align: 16, size: 16, type: 'i32', View: Int32Array },\n    'vec4<u32>': { numElements: 4, align: 16, size: 16, type: 'u32', View: Uint32Array },\n    'vec4<f32>': { numElements: 4, align: 16, size: 16, type: 'f32', View: Float32Array },\n    'vec4': { numElements: 4, align: 16, size: 16, type: 'f32', View: Float32Array },\n    'vec4<f16>': { numElements: 4, align:  8, size:  8, type: 'u16', View: Uint16Array },\n    // AlignOf(vecR)\tSizeOf(array<vecR, C>)\n    'mat2x2<f32>': { numElements:  8, align:  8, size: 16, type: 'f32', View: Float32Array },\n    'mat2x2': { numElements:  8, align:  8, size: 16, type: 'f32', View: Float32Array },\n    'mat2x2<f16>': { numElements:  4, align:  4, size:  8, type: 'u16', View: Uint16Array },\n    'mat3x2<f32>': { numElements:  8, align:  8, size: 24, type: 'f32', View: Float32Array },\n    'mat3x2': { numElements:  8, align:  8, size: 24, type: 'f32', View: Float32Array },\n    'mat3x2<f16>': { numElements:  8, align:  4, size: 12, type: 'u16', View: Uint16Array },\n    'mat4x2<f32>': { numElements:  8, align:  8, size: 32, type: 'f32', View: Float32Array },\n    'mat4x2': { numElements:  8, align:  8, size: 32, type: 'f32', View: Float32Array },\n    'mat4x2<f16>': { numElements:  8, align:  4, size: 16, type: 'u16', View: Uint16Array },\n    'mat2x3<f32>': { numElements: 12, align: 16, size: 32, type: 'f32', View: Float32Array },\n    'mat2x3': { numElements: 12, align: 16, size: 32, type: 'f32', View: Float32Array },\n    'mat2x3<f16>': { numElements: 12, align:  8, size: 16, type: 'u16', View: Uint16Array },\n    'mat3x3<f32>': { numElements: 12, align: 16, size: 48, type: 'f32', View: Float32Array },\n    'mat3x3': { numElements: 12, align: 16, size: 48, type: 'f32', View: Float32Array },\n    'mat3x3<f16>': { numElements: 12, align:  8, size: 24, type: 'u16', View: Uint16Array },\n    'mat4x3<f32>': { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\n    'mat4x3': { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\n    'mat4x3<f16>': { numElements: 16, align:  8, size: 32, type: 'u16', View: Uint16Array },\n    'mat2x4<f32>': { numElements: 16, align: 16, size: 32, type: 'f32', View: Float32Array },\n    'mat2x4': { numElements: 16, align: 16, size: 32, type: 'f32', View: Float32Array },\n    'mat2x4<f16>': { numElements: 16, align:  8, size: 16, type: 'u16', View: Uint16Array },\n    'mat3x4<f32>': { numElements: 16, align: 16, size: 48, type: 'f32', View: Float32Array },\n    'mat3x4': { numElements: 16, align: 16, size: 48, type: 'f32', View: Float32Array },\n    'mat3x4<f16>': { numElements: 16, align:  8, size: 24, type: 'u16', View: Uint16Array },\n    'mat4x4<f32>': { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\n    'mat4x4': { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\n    'mat4x4<f16>': { numElements: 16, align:  8, size: 32, type: 'u16', View: Uint16Array },\n};\n\nexport type TypedArrayOrViews = TypedArray | Views | Views[];\nexport interface Views {\n  [x: string]: TypedArrayOrViews;\n}\nexport type ArrayBufferViews = {\n    views: TypedArrayOrViews;\n    arrayBuffer: ArrayBuffer;\n}\n\n/**\n * Creates a set of named TypedArray views on an ArrayBuffer\n * @param structDef Definition of the various types of views.\n * @param arrayBuffer Optional ArrayBuffer to use (if one provided one will be created)\n * @param offset Optional offset in existing ArrayBuffer to start the views.\n * @returns A bunch of named TypedArray views and the ArrayBuffer\n */\nexport function makeTypedArrayViews(structDef: StructDefinition, arrayBuffer?: ArrayBuffer, offset?: number): ArrayBufferViews {\n    const baseOffset = offset || 0;\n    const buffer = arrayBuffer || new ArrayBuffer(structDef.size);\n\n    const makeViews = (structDef: FieldDefinition): TypedArrayOrViews => {\n        if (Array.isArray(structDef)) {\n            return (structDef as StructDefinition[]).map(elemDef => makeViews(elemDef)) as Views[];\n        } else if (typeof structDef === 'string') {\n            throw Error('unreachable');\n        } else {\n            const fields = (structDef as StructDefinition).fields;\n            if (fields) {\n                const views: Views = {};\n                for (const [name, def] of Object.entries(fields)) {\n                    views[name] = makeViews(def as StructDefinition);\n                }\n                return views;\n            } else {\n                const { size, offset, type } = structDef as IntrinsicDefinition;\n                const { View } = typeInfo[type];\n                const numElements = size / View.BYTES_PER_ELEMENT;\n                return new View(buffer, baseOffset + offset, numElements);\n            }\n        }\n    };\n    return { views: makeViews(structDef), arrayBuffer: buffer };\n}\n\n/**\n * Given a set of TypeArrayViews and matching JavaScript data\n * sets the content of the views.\n * @param data The new values\n * @param views TypedArray views as returned from {@link makeTypedArrayViews}\n */\nexport function setStructuredView(data: any, views: TypedArrayOrViews): void {\n    if (data === undefined) {\n        return;\n    } else if (isTypedArray(views)) {\n        const view = views as TypedArray;\n        if (view.length === 1 && typeof data === 'number') {\n            view[0] = data;\n        } else {\n            view.set(data as number[]);\n        }\n    } else if (Array.isArray(views)) {\n        const asArray = views as Views[];\n        (data as any[]).forEach((newValue, ndx) => {\n            setStructuredView(newValue, asArray[ndx]);\n        });\n    } else {\n        const asViews = views as Views;\n        for (const [key, newValue] of Object.entries(data)) {\n            const view = asViews[key];\n            if (view) {\n                setStructuredView(newValue, view);\n            }\n        }\n    }\n}\n\nexport type StructuredView = ArrayBufferViews & {\n    /**\n     * Sets the contents of the TypedArrays based on the data passed in\n     * Note: The data may be sparse\n     *\n     * example:\n     *\n     * ```js\n     * const code = `\n     * struct HSL {\n     *   hue: f32,\n     *   sat: f32,\n     *   lum: f32,\n     * };\n     * struct MyUniforms {\n     *    colors: array<HSL, 4>,\n     *    brightness: f32,\n     *    kernel: array<f32, 9>,\n     * };\n     * @group(0) @binding(0) var<uniform> myUniforms: MyUniforms;\n     * `;\n     * const defs = makeShaderDataDefinitions(code);\n     * const myUniformValues = makeStructuredView(defs.uniforms.myUniforms);\n     *\n     * myUniformValues.set({\n     *   colors: [\n     *     ,\n     *     ,\n     *     { hue: 0.5, sat: 1.0, lum: 0.5 },  // only set the 3rd color\n     *   ],\n     *   brightness: 0.8,\n     *   kernel: [\n     *      1, 0, -1,\n     *      2, 0, -2,\n     *      1, 0, -1,\n     *   ],\n     * });\n     * ```\n     *\n     * @param data\n     */\n    set(data: any): void;\n}\n\n/**\n * Given a StructDefinition, create matching TypedArray views\n * @param structDef A StructDefinition as returned from {@link makeShaderDataDefinitions}\n * @param arrayBuffer Optional ArrayBuffer for the views\n * @param offset Optional offset into the ArrayBuffer for the views\n * @returns TypedArray views for the various named fields of the structure as well\n *    as a `set` function to make them easy to set, and the arrayBuffer\n */\nexport function makeStructuredView(structDef: StructDefinition, arrayBuffer?: ArrayBuffer, offset = 0): StructuredView {\n    const views = makeTypedArrayViews(structDef, arrayBuffer, offset);\n    return {\n        ...views,\n        set(data: any) {\n            setStructuredView(data, views.views);\n        },\n    };\n}\n\nfunction addMember(reflect: WgslReflect, m: Member, offset: number): [string, StructDefinition | IntrinsicDefinition | IntrinsicDefinition[] | StructDefinition[]] {\n    if (m.isArray) {\n        if (m.isStruct) {\n            return [\n                m.name,\n                new Array(m.arrayCount).fill(0).map((_, ndx) => {\n                    return addMembers(reflect, m.members!, m.size / m.arrayCount, offset + (m.offset || 0) + m.size / m.arrayCount * ndx);\n                }),\n            ];\n        } else {\n            return [\n                m.name,\n                {\n                    offset: offset + (m.offset || 0),\n                    size: m.size,\n                    type: m.type.format!.name!,\n                    numElements: m.arrayCount,\n                },\n            ];\n        }\n    } else if (m.isStruct) {\n        return [\n            m.name,\n            addMembers(reflect, m.members!, m.size, offset + (m.offset || 0)),\n        ];\n    } else {\n        return [\n            m.name,\n            {\n                offset: offset + (m.offset || 0),\n                size: m.size,\n                type: m.type?.name || m.name,\n            },\n        ];\n    }\n}\n\nfunction addMembers(reflect: WgslReflect, members: Member[], size: number, offset = 0): StructDefinition {\n    const fields: FieldDefinitions = Object.fromEntries(members.map(m => {\n        return addMember(reflect, m, offset);\n    }));\n\n    return {\n        fields,\n        size,\n    };\n}\n\nexport type StructDefinitions = {\n    [x: string]: StructDefinition;\n}\n\nexport type StorageDefinitions = {\n    [x: string]: StorageDefinition;\n}\n\ntype ShaderDataDefinitions = {\n    uniforms: StorageDefinitions,\n    storages: StorageDefinitions,\n    structs: StructDefinitions,\n};\n\n/**\n * Given a WGSL shader, returns data definitions for structures,\n * uniforms, and storage buffers\n *\n * Example:\n *\n * ```js\n * const code = `\n * struct MyStruct {\n *    color: vec4<f32>,\n *    brightness: f32,\n *    kernel: array<f32, 9>,\n * };\n * @group(0) @binding(0) var<uniform> myUniforms: MyUniforms;\n * `;\n * const defs = makeShaderDataDefinitions(code);\n * const myUniformValues = makeStructuredView(defs.uniforms.myUniforms);\n *\n * myUniformValues.set({\n *   color: [1, 0, 1, 1],\n *   brightness: 0.8,\n *   kernel: [\n *      1, 0, -1,\n *      2, 0, -2,\n *      1, 0, -1,\n *   ],\n * });\n * device.queue.writeBuffer(uniformBuffer, 0, myUniformValues.arrayBuffer);\n * ```\n *\n * @param code WGSL shader. Note: it is not required for this to be a complete shader\n * @returns definitions of the structures by name. Useful for passing to {@link makeStructuredView}\n */\nexport function makeShaderDataDefinitions(code: string): ShaderDataDefinitions {\n    const reflect = new WgslReflect(code);\n\n    const structs = Object.fromEntries(reflect.structs.map(struct => {\n        const info = reflect.getStructInfo(struct);\n        return [struct.name, addMembers(reflect, info.members, info.size)];\n    }));\n\n    const uniforms = Object.fromEntries(reflect.uniforms.map(uniform => {\n        const info = reflect.getUniformBufferInfo(uniform);\n        const member = addMember(reflect, info, 0)[1] as StorageDefinition;\n        member.binding = info.binding;\n        member.group = info.group;\n        return [uniform.name, member];\n    }));\n\n    const storages = Object.fromEntries(reflect.storage.map(uniform => {\n        const info = reflect.getStorageBufferInfo(uniform);\n        const member = addMember(reflect, info, 0)[1] as StorageDefinition;\n        member.binding = info.binding;\n        member.group = info.group;\n        return [uniform.name, member];\n    }));\n\n    return {\n        structs,\n        storages,\n        uniforms,\n    };\n}\n\ntype ViewsByCtor = Map<TypedArrayConstructor, TypedArray>;\nconst s_views = new WeakMap<ArrayBuffer, ViewsByCtor>();\n\n\nfunction getViewsByCtor(arrayBuffer: ArrayBuffer): ViewsByCtor {\n    let viewsByCtor = s_views.get(arrayBuffer);\n    if (!viewsByCtor) {\n        viewsByCtor = new Map();\n        s_views.set(arrayBuffer, viewsByCtor);\n    }\n    return viewsByCtor;\n}\n\nfunction getView<T extends TypedArray>(arrayBuffer: ArrayBuffer, Ctor: TypedArrayConstructor): T {\n    const viewsByCtor = getViewsByCtor(arrayBuffer);\n    let view = viewsByCtor.get(Ctor);\n    if (!view) {\n        view = new Ctor(arrayBuffer);\n        viewsByCtor.set(Ctor, view);\n    }\n    return view as T;\n}\n\nexport function setStructuredValues(fieldDef: FieldDefinition, data: any, arrayBuffer: ArrayBuffer, offset = 0) {\n    const asIntrinsicDefinition = fieldDef as IntrinsicDefinition;\n    if (asIntrinsicDefinition.type) {\n        const type = typeInfo[asIntrinsicDefinition.type];\n        const view = getView(arrayBuffer, type.View);\n        const index = (offset + asIntrinsicDefinition.offset) / view.BYTES_PER_ELEMENT;\n        if (typeof data === 'number') {\n            view[index] = data;\n        } else {\n            view.set(data, index);\n        }\n    } else if (Array.isArray(fieldDef)) {\n        // It's IntrinsicDefinition[] or StructDefinition[]\n        data.forEach((newValue: any, ndx: number) => {\n            setStructuredValues(fieldDef[ndx], newValue, arrayBuffer, offset);\n        });\n    } else {\n        // It's StructDefinition\n        const asStructDefinition = fieldDef as StructDefinition;\n        for (const [key, newValue] of Object.entries(data)) {\n            const fieldDef = asStructDefinition.fields[key];\n            if (fieldDef) {\n                setStructuredValues(fieldDef, newValue, arrayBuffer, offset);\n            }\n        }\n    }\n}"],"names":["Token","constructor","type","lexeme","line","this","_type","_lexeme","_line","toString","EOF","name","rule","Keyword","WgslScanner","source","_source","_tokens","_start","_current","scanTokens","_isAtEnd","scanToken","push","_advance","_isWhitespace","_peekAhead","commentLevel","matchToken","matchedToken","_findToken","foundLessThan","ti","length","count","less_than","template_types","indexOf","_addToken","lookAheadLexeme","lookAhead","maxLookAhead","li","token","_match","Tokens","match","exec","index","c","amount","offset","text","substring","WgslTokens","decimal_float_literal","hex_float_literal","int_literal","uint_literal","ident","and","and_and","arrow","attr","attr_left","attr_right","forward_slash","bang","bracket_left","bracket_right","brace_left","brace_right","colon","comma","equal","equal_equal","not_equal","greater_than","greater_than_equal","shift_right","less_than_equal","shift_left","modulo","minus","minus_minus","period","plus","plus_plus","or","or_or","paren_left","paren_right","semicolon","star","tilde","underscore","xor","plus_equal","minus_equal","times_equal","division_equal","modulo_equal","and_equal","or_equal","xor_equal","shift_right_equal","shift_left_equal","WgslKeywords","WgslReserved","i","l","int32","i32","uint32","u32","float32","f32","pointer","ptr","storage_class","function","private","workgroup","uniform","storage","access_mode","read","write","read_write","sampler_type","sampler","sampler_comparison","sampled_texture_type","texture_1d","texture_2d","texture_2d_array","texture_3d","texture_cube","texture_cube_array","multisampled_texture_type","texture_multisampled_2d","storage_texture_type","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","depth_texture_type","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","texture_depth_multisampled_2d","any_texture_type","texel_format","r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm_srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm_srgb","rgb10a2unorm","rg11b10float","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","const_literal","true","false","literal_or_ident","element_count_expression","vec2","vec3","vec4","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","atomic","bitcast","attribute_name","block","assignment_operators","increment_operators","_InitTokens","AST","options","option","WgslParser","parse","tokensOrCode","_initialize","statements","statement","_global_decl_or_directive","scanner","_error","message","console","error","_peek","types","undefined","_check","_consume","t","_previous","_type_alias","enable","_enable_directive","attrs","_attribute","var","_var","_global_variable_decl","attributes","let","_let","_global_constant_decl","struct","_struct","_struct_decl","fn","_fn","_function_decl","args","argAttrs","typeAttrs","_type_decl","_return","body","_compound_statement","return","_statement","if","_if_statement","switch","_switch_statement","loop","_loop_statement","for","_for_statement","while","_while_statement","static_assert","_static_assert_statement","result","_return_statement","const","_variable_statement","discard","break","continue","_increment_decrement_statement","_func_call_statement","_assignment_statement","expression","_optional_paren_expression","condition","init","_for_init","_short_circuit_or_expression","increment","_for_increment","_variable_decl","value","savedPos","_unary_expression","isUnderscore","_argument_expression_list","continuing","_switch_body","cases","case","selector","_case_selectors","_case_body","default","_cases","selectors","fallthrough","nextStatement","elseif","_elseif_statement","_else","else","expr","_short_circuit_and_expr","operator","left","right","_inclusive_or_expression","_exclusive_or_expression","_and_expression","_equality_expression","_relational_expression","_shift_expression","_additive_expression","_multiplicative_expression","_singular_expression","_primary_expression","p","_postfix_expression","postfix","_paren_expression","arg","contents","members","memberAttrs","memberName","memberType","_const_expression","access","alias","bool","format","decl","_texture_sampler_types","array","v","WgslReflect","code","initialize","parser","ast","structs","uniforms","textures","samplers","functions","aliases","entry","vertex","fragment","compute","node","isUniformVar","group","getAttribute","parseInt","binding","isStorageVar","isTextureVar","isSamplerVar","vertexStage","fragmentStage","computeStage","stage","inputs","_getInputs","TextureTypes","SamplerTypes","input","_getInputInfo","getStruct","location","locationType","_parseInt","interpolation","s","n","isNaN","getAlias","u","a","getBindGroups","groups","_makeRoom","resource","getUniformBufferInfo","getStorageBufferInfo","_getUniformInfo","getStructInfo","lastSize","lastOffset","structAlign","buffer","align","size","mi","ml","member","info","getTypeInfo","_roundUp","Math","max","isArray","isStruct","si","arrayStride","arrayCount","explicitSize","sizeAttr","explicitAlign","alignAttr","TypeInfo","E","N","stride","m","k","ceil","map","roundUpToMultipleOf","multiple","isTypedArray","arr","ArrayBuffer","byteLength","typeInfo","numElements","View","Int32Array","Uint32Array","Float32Array","f16","Uint16Array","makeTypedArrayViews","structDef","arrayBuffer","baseOffset","makeViews","Array","elemDef","Error","fields","views","def","Object","entries","BYTES_PER_ELEMENT","setStructuredView","data","view","set","asArray","forEach","newValue","ndx","asViews","key","addMember","reflect","fill","_","addMembers","fromEntries","s_views","WeakMap","getView","Ctor","viewsByCtor","get","Map","getViewsByCtor","byteOffset","sizeInBytes","alignment","pad","numBytes","storages","setStructuredValues","fieldDef","asIntrinsicDefinition","asStructDefinition"],"mappings":"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cAAcwB,GACV,MAAY,KAALA,GAAiB,MAALA,GAAkB,MAALA,CACnC,CAEDzB,SAAS0B,GACL,IAAID,EAAI5C,KAAKW,QAAQX,KAAKc,UAI1B,OAHA+B,EAASA,GAAU,EACnBA,IACA7C,KAAKc,UAAY+B,EACVD,CACV,CAEDvB,WAAWyB,GAEP,OADAA,EAASA,GAAU,EACf9C,KAAKc,SAAWgC,GAAU9C,KAAKW,QAAQiB,OAAe,KACnD5B,KAAKW,QAAQX,KAAKc,SAAWgC,EACvC,CAEDb,UAAUpC,GACN,MAAMkD,EAAO/C,KAAKW,QAAQqC,UAAUhD,KAAKa,OAAQb,KAAKc,UACtDd,KAAKY,QAAQM,KAAK,IAAIvB,EAAME,EAAMkD,EAAM/C,KAAKG,OAChD,EAGLR,EAAMsD,WAAa,CACfC,sBACI,8FACJC,kBACI,4HACJC,YACI,mCACJC,aACI,kCACJC,MACI,wBACJC,IACI,IACJC,QACI,KACJC,MACI,KACJC,KACI,IACJC,UACI,KACJC,WACI,KACJC,cACI,IACJC,KACI,IACJC,aACI,IACJC,cACI,IACJC,WACI,IACJC,YACI,IACJC,MACI,IACJC,MACI,IACJC,MACI,IACJC,YACI,KACJC,UACI,KACJC,aACI,IACJC,mBACI,KACJC,YACI,KACJ5C,UACI,IACJ6C,gBACI,KACJC,WACI,KACJC,OACI,IACJC,MACI,IACJC,YACI,KACJC,OACI,IACJC,KACI,IACJC,UACI,KACJC,GACI,IACJC,MACI,KACJC,WACI,IACJC,YACI,IACJC,UACI,IACJC,KACI,IACJC,MACI,IACJC,WACI,IACJC,IACI,IAEJC,WACI,KACJC,YACI,KACJC,YACI,KACJC,eACI,KACJC,aACI,KACJC,UACI,KACJC,SACI,KACJC,UACI,KACJC,kBACI,MACJC,iBACI,OAGR1G,EAAM2G,aAAe,CACjB,QACA,SACA,OACA,MACA,MACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,MACA,UACA,qBACA,SACA,aACA,aACA,mBACA,aACA,eACA,qBACA,0BACA,qBACA,qBACA,2B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"}