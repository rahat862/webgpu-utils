{"version":3,"file":"webgpu-utils.module.js","sources":["../../src/3rdParty/wgsl_reflect/wgsl_reflect.module.js","../../../src/webgpu-utils.ts"],"sourcesContent":["/**\r\n * @author Brendan Duncan / https://github.com/brendan-duncan\r\n */\r\n\r\nclass Token {\r\n    constructor(type, lexeme, line) {\r\n        this._type = type;\r\n        this._lexeme = lexeme;\r\n        this._line = line;\r\n    }\r\n\r\n    toString() {\r\n        return this._lexeme;\r\n    }\r\n}\r\n\r\nToken.EOF = { name: \"EOF\", type: \"token\", rule: -1 };\r\n\r\nlet Keyword = {};\r\n\r\nclass WgslScanner {\r\n    constructor(source) {\r\n        this._source = source || \"\";\r\n        this._tokens = [];\r\n        this._start = 0;\r\n        this._current = 0;\r\n        this._line = 1;\r\n    }\r\n\r\n    scanTokens() {\r\n        while (!this._isAtEnd()) {\r\n            this._start = this._current;\r\n            if (!this.scanToken())\r\n                throw `Invalid syntax at line ${this._line}`;\r\n        }\r\n\r\n        this._tokens.push(new Token(Token.EOF, \"\", this._line));\r\n        return this._tokens;\r\n    }\r\n\r\n    scanToken() {\r\n        // Find the longest consecutive set of characters that match a rule.\r\n        let lexeme = this._advance();\r\n\r\n        // Skip line-feed, adding to the line counter.\r\n        if (lexeme == \"\\n\") {\r\n            this._line++;\r\n            return true;\r\n        }\r\n\r\n        // Skip whitespace\r\n        if (this._isWhitespace(lexeme)) {\r\n            return true;\r\n        }\r\n\r\n        if (lexeme == \"/\") {\r\n            // If it's a // comment, skip everything until the next line-feed.\r\n            if (this._peekAhead() == \"/\") {\r\n                while (lexeme != \"\\n\") {\r\n                    if (this._isAtEnd())\r\n                        return true;\r\n                    lexeme = this._advance();\r\n                }\r\n                // skip the linefeed\r\n                this._line++;\r\n                return true;\r\n            } else if (this._peekAhead() == \"*\") {\r\n                // If it's a /* block comment, skip everything until the matching */,\r\n                // allowing for nested block comments.\r\n                this._advance();\r\n                let commentLevel = 1;\r\n                while (commentLevel > 0) {\r\n                    if (this._isAtEnd())\r\n                        return true;\r\n                    lexeme = this._advance();\r\n                    if (lexeme == \"\\n\") {\r\n                        this._line++;\r\n                    } else if (lexeme == \"*\") {\r\n                        if (this._peekAhead() == \"/\") {\r\n                            this._advance();\r\n                            commentLevel--;\r\n                            if (commentLevel == 0) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    } else if (lexeme == \"/\") {\r\n                        if (this._peekAhead() == \"*\") {\r\n                            this._advance();\r\n                            commentLevel++;\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n\r\n        let matchToken = null;\r\n\r\n        for (;;) {\r\n            let matchedToken = this._findToken(lexeme);\r\n\r\n            // The exception to \"longest lexeme\" rule is '>>'. In the case of 1>>2, it's a shift_right.\r\n            // In the case of array<vec4<f32>>, it's two greater_than's (one to close the vec4,\r\n            // and one to close the array).\r\n            // I don't know of a great way to resolve this, so '>>' is special-cased and if\r\n            // there was a less_than up to some number of tokens previously, and the token prior to\r\n            // that is a keyword that requires a '<', then it will be split into two greater_than's;\r\n            // otherwise it's a shift_right.\r\n            if (lexeme == \">\" && this._peekAhead() == \">\") {\r\n                let foundLessThan = false;\r\n                let ti = this._tokens.length - 1;\r\n                for (let count = 0; count < 4 && ti >= 0; ++count, --ti) {\r\n                    if (this._tokens[ti]._type == Token.less_than) {\r\n                        if (ti > 0 && Token.template_types.indexOf(this._tokens[ti - 1]._type) != -1) {\r\n                            foundLessThan = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                // If there was a less_than in the recent token history, then this is probably a\r\n                // greater_than.\r\n                if (foundLessThan) {\r\n                    this._addToken(matchedToken);\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // The current lexeme may not match any rule, but some token types may be invalid for\r\n            // part of the string but valid after a few more characters.\r\n            // For example, 0x.5 is a hex_float_literal. But as it's being scanned,\r\n            // \"0\" is a int_literal, then \"0x\" is invalid. If we stopped there, it would return\r\n            // the int_literal \"0\", but that's incorrect. So if we look forward a few characters,\r\n            // we'd get \"0x.\", which is still invalid, followed by \"0x.5\" which is the correct\r\n            // hex_float_literal. So that means if we hit an non-matching string, we should look\r\n            // ahead up to two characters to see if the string starts matching a valid rule again.\r\n            if (!matchedToken) {\r\n                let lookAheadLexeme = lexeme;\r\n                let lookAhead = 0;\r\n                const maxLookAhead = 2;\r\n                for (let li = 0; li < maxLookAhead; ++li) {\r\n                    lookAheadLexeme += this._peekAhead(li);\r\n                    matchedToken = this._findToken(lookAheadLexeme);\r\n                    if (matchedToken) {\r\n                        lookAhead = li;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!matchedToken) {\r\n                    if (!matchToken)\r\n                        return false;\r\n                    this._current--;\r\n                    this._addToken(matchToken);\r\n                    return true;\r\n                }\r\n\r\n                lexeme = lookAheadLexeme;\r\n                this._current += lookAhead + 1;\r\n            }\r\n\r\n            matchToken = matchedToken;\r\n\r\n            if (this._isAtEnd())\r\n                break;\r\n\r\n            lexeme += this._advance();\r\n        }\r\n\r\n        // We got to the end of the input stream. Then the token we've ready so far is it.\r\n        if (matchToken === null)\r\n            return false;\r\n\r\n        this._addToken(matchToken);\r\n        return true;\r\n    }\r\n\r\n    _findToken(lexeme) {\r\n        for (const name in Keyword) {\r\n            const token = Keyword[name];\r\n            if (this._match(lexeme, token.rule)) {\r\n                return token;\r\n            }\r\n        }\r\n        for (const name in Token.Tokens) {\r\n            const token = Token.Tokens[name];\r\n            if (this._match(lexeme, token.rule)) {\r\n                return token;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _match(lexeme, rule) {\r\n        if (typeof(rule) == \"string\") {\r\n            if (rule == lexeme) {\r\n                return true;\r\n            }\r\n        } else {\r\n            // regex\r\n            const match = rule.exec(lexeme);\r\n            if (match && match.index == 0 && match[0] == lexeme)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    _isAtEnd() {\r\n        return this._current >= this._source.length;\r\n    }\r\n\r\n    _isWhitespace(c) {\r\n        return c == \" \" || c == \"\\t\" || c == \"\\r\";\r\n    }\r\n\r\n    _advance(amount) {\r\n        let c = this._source[this._current];\r\n        amount = amount || 0;\r\n        amount++;\r\n        this._current += amount;\r\n        return c;\r\n    }\r\n\r\n    _peekAhead(offset) {\r\n        offset = offset || 0;\r\n        if (this._current + offset >= this._source.length) return \"\\0\";\r\n        return this._source[this._current + offset];\r\n    }\r\n\r\n    _addToken(type) {\r\n        const text = this._source.substring(this._start, this._current);\r\n        this._tokens.push(new Token(type, text, this._line));\r\n    }\r\n}\r\n\r\nToken.WgslTokens = {\r\n    decimal_float_literal:\r\n        /((-?[0-9]*\\.[0-9]+|-?[0-9]+\\.[0-9]*)((e|E)(\\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\\+|-)?[0-9]+f?)/,\r\n    hex_float_literal:\r\n        /-?0x((([0-9a-fA-F]*\\.[0-9a-fA-F]+|[0-9a-fA-F]+\\.[0-9a-fA-F]*)((p|P)(\\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\\+|-)?[0-9]+f?))/,\r\n    int_literal:\r\n        /-?0x[0-9a-fA-F]+|0|-?[1-9][0-9]*/,\r\n    uint_literal:\r\n        /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/,\r\n    ident:\r\n        /[a-zA-Z][0-9a-zA-Z_]*/,\r\n    and:\r\n        '&',\r\n    and_and:\r\n        '&&',\r\n    arrow :\r\n        '->',\r\n    attr:\r\n        '@',\r\n    attr_left:\r\n        '[[',\r\n    attr_right:\r\n        ']]',\r\n    forward_slash:\r\n        '/',\r\n    bang:\r\n        '!',\r\n    bracket_left:\r\n        '[',\r\n    bracket_right:\r\n        ']',\r\n    brace_left:\r\n        '{',\r\n    brace_right:\r\n        '}',\r\n    colon:\r\n        ':',\r\n    comma:\r\n        ',',\r\n    equal:\r\n        '=',\r\n    equal_equal:\r\n        '==',\r\n    not_equal:\r\n        '!=',\r\n    greater_than:\r\n        '>',\r\n    greater_than_equal:\r\n        '>=',\r\n    shift_right:\r\n        '>>',\r\n    less_than:\r\n        '<',\r\n    less_than_equal:\r\n        '<=',\r\n    shift_left:\r\n        '<<',\r\n    modulo:\r\n        '%',\r\n    minus:\r\n        '-',\r\n    minus_minus:\r\n        '--',\r\n    period:\r\n        '.',\r\n    plus:\r\n        '+',\r\n    plus_plus:\r\n        '++',\r\n    or:\r\n        '|',\r\n    or_or:\r\n        '||',\r\n    paren_left:\r\n        '(',\r\n    paren_right:\r\n        ')',\r\n    semicolon:\r\n        ';',\r\n    star:\r\n        '*',\r\n    tilde:\r\n        '~',\r\n    underscore:\r\n        '_',\r\n    xor:\r\n        '^',\r\n\r\n    plus_equal:\r\n        '+=',\r\n    minus_equal:\r\n        '-=',\r\n    times_equal:\r\n        '*=',\r\n    division_equal:\r\n        '/=',\r\n    modulo_equal:\r\n        '%=',\r\n    and_equal:\r\n        '&=',\r\n    or_equal:\r\n        '|=',\r\n    xor_equal:\r\n        '^=',\r\n    shift_right_equal:\r\n        '>>=',\r\n    shift_left_equal:\r\n        '<<=',\r\n};\r\n\r\nToken.WgslKeywords = [\r\n    \"array\",\r\n    \"atomic\",\r\n    \"bool\",\r\n    \"f32\",\r\n    \"i32\",\r\n    \"mat2x2\",\r\n    \"mat2x3\",\r\n    \"mat2x4\",\r\n    \"mat3x2\",\r\n    \"mat3x3\",\r\n    \"mat3x4\",\r\n    \"mat4x2\",\r\n    \"mat4x3\",\r\n    \"mat4x4\",\r\n    \"ptr\",\r\n    \"sampler\",\r\n    \"sampler_comparison\",\r\n    \"struct\",\r\n    \"texture_1d\",\r\n    \"texture_2d\",\r\n    \"texture_2d_array\",\r\n    \"texture_3d\",\r\n    \"texture_cube\",\r\n    \"texture_cube_array\",\r\n    \"texture_multisampled_2d\",\r\n    \"texture_storage_1d\",\r\n    \"texture_storage_2d\",\r\n    \"texture_storage_2d_array\",\r\n    \"texture_storage_3d\",\r\n    \"texture_depth_2d\",\r\n    \"texture_depth_2d_array\",\r\n    \"texture_depth_cube\",\r\n    \"texture_depth_cube_array\",\r\n    \"texture_depth_multisampled_2d\",\r\n    \"u32\",\r\n    \"vec2\",\r\n    \"vec3\",\r\n    \"vec4\",\r\n    \"bitcast\",\r\n    \"block\",\r\n    \"break\",\r\n    \"case\",\r\n    \"continue\",\r\n    \"continuing\",\r\n    \"default\",\r\n    \"discard\",\r\n    \"else\",\r\n    \"elseif\",\r\n    \"enable\",\r\n    \"fallthrough\",\r\n    \"false\",\r\n    \"fn\",\r\n    \"for\",\r\n    \"function\",\r\n    \"if\",\r\n    \"let\",\r\n    \"const\",\r\n    \"loop\",\r\n    \"while\",\r\n    \"private\",\r\n    \"read\",\r\n    \"read_write\",\r\n    \"return\",\r\n    \"storage\",\r\n    \"switch\",\r\n    \"true\",\r\n    \"type\",\r\n    \"uniform\",\r\n    \"var\",\r\n    \"workgroup\",\r\n    \"write\",\r\n    \"r8unorm\",\r\n    \"r8snorm\",\r\n    \"r8uint\",\r\n    \"r8sint\",\r\n    \"r16uint\",\r\n    \"r16sint\",\r\n    \"r16float\",\r\n    \"rg8unorm\",\r\n    \"rg8snorm\",\r\n    \"rg8uint\",\r\n    \"rg8sint\",\r\n    \"r32uint\",\r\n    \"r32sint\",\r\n    \"r32float\",\r\n    \"rg16uint\",\r\n    \"rg16sint\",\r\n    \"rg16float\",\r\n    \"rgba8unorm\",\r\n    \"rgba8unorm_srgb\",\r\n    \"rgba8snorm\",\r\n    \"rgba8uint\",\r\n    \"rgba8sint\",\r\n    \"bgra8unorm\",\r\n    \"bgra8unorm_srgb\",\r\n    \"rgb10a2unorm\",\r\n    \"rg11b10float\",\r\n    \"rg32uint\",\r\n    \"rg32sint\",\r\n    \"rg32float\",\r\n    \"rgba16uint\",\r\n    \"rgba16sint\",\r\n    \"rgba16float\",\r\n    \"rgba32uint\",\r\n    \"rgba32sint\",\r\n    \"rgba32float\",\r\n    \"static_assert\"\r\n];\r\n\r\nToken.WgslReserved = [\r\n    \"asm\",\r\n    \"bf16\",\r\n    \"do\",\r\n    \"enum\",\r\n    \"f16\",\r\n    \"f64\",\r\n    \"handle\",\r\n    \"i8\",\r\n    \"i16\",\r\n    \"i64\",\r\n    \"mat\",\r\n    \"premerge\",\r\n    \"regardless\",\r\n    \"typedef\",\r\n    \"u8\",\r\n    \"u16\",\r\n    \"u64\",\r\n    \"unless\",\r\n    \"using\",\r\n    \"vec\",\r\n    \"void\"\r\n];\r\n\r\nfunction _InitTokens() {\r\n    Token.Tokens = {};\r\n    for (let token in Token.WgslTokens) {\r\n        Token.Tokens[token] = {\r\n            name: token,\r\n            type: \"token\",\r\n            rule: Token.WgslTokens[token],\r\n            toString: function() { return token; }\r\n        };\r\n        Token[token] = Token.Tokens[token];\r\n    }\r\n\r\n    for (let i = 0, l = Token.WgslKeywords.length; i < l; ++i) {\r\n        Keyword[Token.WgslKeywords[i]] = {\r\n            name: Token.WgslKeywords[i],\r\n            type: \"keyword\",\r\n            rule: Token.WgslKeywords[i],\r\n            toString: function() { return Token.WgslKeywords[i]; }\r\n        };\r\n    }\r\n\r\n    for (let i = 0, l = Token.WgslReserved.length; i < l; ++i) {\r\n        Keyword[Token.WgslReserved[i]] = {\r\n            name: Token.WgslReserved[i], \r\n            type: \"reserved\",\r\n            rule: Token.WgslReserved[i],\r\n            toString: function() { return Token.WgslReserved[i]; }\r\n        };\r\n    }\r\n\r\n    // WGSL grammar has a few keywords that have different token names than the strings they\r\n    // represent. Aliasing them here.\r\n\r\n    Keyword.int32 = Keyword.i32;\r\n    Keyword.uint32 = Keyword.u32;\r\n    Keyword.float32 = Keyword.f32;\r\n    Keyword.pointer = Keyword.ptr;\r\n\r\n    // The grammar has a few rules where the rule can match to any one of a given set of keywords\r\n    // or tokens. Defining those here.\r\n\r\n    Token.storage_class = [\r\n        Keyword.function,\r\n        Keyword.private,\r\n        Keyword.workgroup,\r\n        Keyword.uniform,\r\n        Keyword.storage\r\n    ];\r\n    \r\n    Token.access_mode = [\r\n        Keyword.read,\r\n        Keyword.write,\r\n        Keyword.read_write\r\n    ];\r\n    \r\n    Token.sampler_type = [\r\n        Keyword.sampler,\r\n        Keyword.sampler_comparison\r\n    ];\r\n    \r\n    Token.sampled_texture_type = [\r\n        Keyword.texture_1d,\r\n        Keyword.texture_2d,\r\n        Keyword.texture_2d_array,\r\n        Keyword.texture_3d,\r\n        Keyword.texture_cube,\r\n        Keyword.texture_cube_array\r\n    ];\r\n    \r\n    Token.multisampled_texture_type = [\r\n        Keyword.texture_multisampled_2d\r\n    ];\r\n    \r\n    Token.storage_texture_type = [\r\n        Keyword.texture_storage_1d,\r\n        Keyword.texture_storage_2d,\r\n        Keyword.texture_storage_2d_array,\r\n        Keyword.texture_storage_3d\r\n    ];\r\n    \r\n    Token.depth_texture_type = [\r\n        Keyword.texture_depth_2d,\r\n        Keyword.texture_depth_2d_array,\r\n        Keyword.texture_depth_cube,\r\n        Keyword.texture_depth_cube_array,\r\n        Keyword.texture_depth_multisampled_2d\r\n    ];\r\n\r\n    Token.any_texture_type = [\r\n        ...Token.sampled_texture_type,\r\n        ...Token.multisampled_texture_type,\r\n        ...Token.storage_texture_type,\r\n        ...Token.depth_texture_type\r\n    ];\r\n\r\n    Token.texel_format = [\r\n        Keyword.r8unorm,\r\n        Keyword.r8snorm,\r\n        Keyword.r8uint,\r\n        Keyword.r8sint,\r\n        Keyword.r16uint,\r\n        Keyword.r16sint,\r\n        Keyword.r16float,\r\n        Keyword.rg8unorm,\r\n        Keyword.rg8snorm,\r\n        Keyword.rg8uint,\r\n        Keyword.rg8sint,\r\n        Keyword.r32uint,\r\n        Keyword.r32sint,\r\n        Keyword.r32float,\r\n        Keyword.rg16uint,\r\n        Keyword.rg16sint,\r\n        Keyword.rg16float,\r\n        Keyword.rgba8unorm,\r\n        Keyword.rgba8unorm_srgb,\r\n        Keyword.rgba8snorm,\r\n        Keyword.rgba8uint,\r\n        Keyword.rgba8sint,\r\n        Keyword.bgra8unorm,\r\n        Keyword.bgra8unorm_srgb,\r\n        Keyword.rgb10a2unorm,\r\n        Keyword.rg11b10float,\r\n        Keyword.rg32uint,\r\n        Keyword.rg32sint,\r\n        Keyword.rg32float,\r\n        Keyword.rgba16uint,\r\n        Keyword.rgba16sint,\r\n        Keyword.rgba16float,\r\n        Keyword.rgba32uint,\r\n        Keyword.rgba32sint,\r\n        Keyword.rgba32float\r\n    ];\r\n\r\n    Token.const_literal = [\r\n        Token.int_literal,\r\n        Token.uint_literal,\r\n        Token.decimal_float_literal,\r\n        Token.hex_float_literal,\r\n        Keyword.true,\r\n        Keyword.false\r\n    ];\r\n\r\n    Token.literal_or_ident = [\r\n        Token.ident,\r\n        Token.int_literal,\r\n        Token.uint_literal,\r\n        Token.decimal_float_literal,\r\n        Token.hex_float_literal,\r\n    ];\r\n\r\n    Token.element_count_expression = [\r\n        Token.int_literal,\r\n        Token.uint_literal,\r\n        Token.ident\r\n    ];\r\n\r\n    Token.template_types = [\r\n        Keyword.vec2,\r\n        Keyword.vec3,\r\n        Keyword.vec4,\r\n        Keyword.mat2x2,\r\n        Keyword.mat2x3,\r\n        Keyword.mat2x4,\r\n        Keyword.mat3x2,\r\n        Keyword.mat3x3,\r\n        Keyword.mat3x4,\r\n        Keyword.mat4x2,\r\n        Keyword.mat4x3,\r\n        Keyword.mat4x4,\r\n        Keyword.atomic,\r\n\r\n        Keyword.bitcast,\r\n\r\n        ...Token.any_texture_type,\r\n    ];\r\n\r\n    // The grammar calls out 'block', but attribute grammar is defined to use a 'ident'.\r\n    // The attribute grammar should be ident | block.\r\n    Token.attribute_name = [\r\n        Token.ident,\r\n        Keyword.block,\r\n    ];\r\n\r\n    Token.assignment_operators = [\r\n        Token.equal,\r\n        Token.plus_equal,\r\n        Token.minus_equal,\r\n        Token.times_equal,\r\n        Token.division_equal,\r\n        Token.modulo_equal,\r\n        Token.and_equal,\r\n        Token.or_equal,\r\n        Token.xor_equal,\r\n        Token.shift_right_equal,\r\n        Token.shift_left_equal\r\n    ];\r\n\r\n    Token.increment_operators = [\r\n        Token.plus_plus,\r\n        Token.minus_minus\r\n    ];\r\n}\r\n_InitTokens();\r\n\r\n/**\r\n * @author Brendan Duncan / https://github.com/brendan-duncan\r\n */\r\n\r\nclass AST {\r\n    constructor(type, options) {\r\n        this._type = type;\r\n        if (options) {\r\n            for (let option in options) {\r\n                this[option] = options[option];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass WgslParser {\r\n    constructor() {\r\n        this._tokens = [];\r\n        this._current = 0;\r\n    }\r\n\r\n    parse(tokensOrCode) {\r\n        this._initialize(tokensOrCode);\r\n\r\n        let statements = [];\r\n        while (!this._isAtEnd()) {\r\n            const statement = this._global_decl_or_directive();\r\n            if (!statement)\r\n                break;\r\n            statements.push(statement);\r\n        }\r\n        return statements;\r\n    }\r\n\r\n    _initialize(tokensOrCode) {\r\n        if (tokensOrCode) {\r\n            if (typeof(tokensOrCode) == \"string\") {\r\n                const scanner = new WgslScanner(tokensOrCode);\r\n                this._tokens = scanner.scanTokens();\r\n            } else {\r\n                this._tokens = tokensOrCode;\r\n            }\r\n        } else {\r\n            this._tokens = [];\r\n        }\r\n        this._current = 0;\r\n    }\r\n\r\n    _error(token, message) {\r\n        console.error(token, message);\r\n        return { token, message, toString: function() { return `${message}`; } };\r\n    }\r\n\r\n    _isAtEnd() { return this._current >= this._tokens.length || this._peek()._type == Token.EOF; }\r\n\r\n    _match(types) {\r\n        if (types.length === undefined) {\r\n            if (this._check(types)) {\r\n                this._advance();\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0, l = types.length; i < l; ++i) {\r\n            const type = types[i];\r\n            if (this._check(type)) {\r\n                this._advance();\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    _consume(types, message) {\r\n        if (this._check(types)) return this._advance();\r\n        throw this._error(this._peek(), message);\r\n    }\r\n\r\n    _check(types) {\r\n        if (this._isAtEnd()) return false;\r\n        if (types.length !== undefined) {\r\n            let t = this._peek()._type;\r\n            return types.indexOf(t) != -1;\r\n        }\r\n        return this._peek()._type == types;\r\n    }\r\n\r\n    _advance() {\r\n        if (!this._isAtEnd()) this._current++;\r\n        return this._previous();\r\n    }\r\n\r\n    _peek() {\r\n        return this._tokens[this._current];\r\n    }\r\n\r\n    _previous() {\r\n        return this._tokens[this._current - 1];\r\n    }\r\n\r\n    _global_decl_or_directive() {\r\n        // semicolon\r\n        // global_variable_decl semicolon\r\n        // global_constant_decl semicolon\r\n        // type_alias semicolon\r\n        // struct_decl\r\n        // function_decl\r\n        // enable_directive\r\n\r\n        // Ignore any stand-alone semicolons\r\n        while (this._match(Token.semicolon) && !this._isAtEnd());\r\n\r\n        if (this._match(Keyword.type)) {\r\n            const type = this._type_alias();\r\n            this._consume(Token.semicolon, \"Expected ';'\");\r\n            return type;\r\n        }\r\n\r\n        if (this._match(Keyword.enable)) {\r\n            const enable = this._enable_directive();\r\n            this._consume(Token.semicolon, \"Expected ';'\");\r\n            return enable;\r\n        }\r\n\r\n        // The following statements have an optional attribute*\r\n        const attrs = this._attribute();\r\n\r\n        if (this._check(Keyword.var)) {\r\n            const _var = this._global_variable_decl();\r\n            _var.attributes = attrs;\r\n            this._consume(Token.semicolon, \"Expected ';'.\");\r\n            return _var;\r\n        }\r\n\r\n        if (this._check(Keyword.let)) {\r\n            const _let = this._global_constant_decl();\r\n            _let.attributes = attrs;\r\n            this._consume(Token.semicolon, \"Expected ';'.\");\r\n            return _let;\r\n        }\r\n\r\n        if (this._check(Keyword.struct)) {\r\n            const _struct = this._struct_decl();\r\n            _struct.attributes = attrs;\r\n            return _struct;\r\n        }\r\n\r\n        if (this._check(Keyword.fn)) {\r\n            const _fn = this._function_decl();\r\n            _fn.attributes = attrs;\r\n            return _fn;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    _function_decl() {\r\n        // attribute* function_header compound_statement\r\n        // function_header: fn ident paren_left param_list? paren_right (arrow attribute* type_decl)?\r\n        if (!this._match(Keyword.fn))\r\n            return null;\r\n\r\n        const name = this._consume(Token.ident, \"Expected function name.\").toString();\r\n\r\n        this._consume(Token.paren_left, \"Expected '(' for function arguments.\");\r\n\r\n        const args = [];\r\n        if (!this._check(Token.paren_right)) {\r\n            do {\r\n                if (this._check(Token.paren_right))\r\n                    break;\r\n                const argAttrs = this._attribute();\r\n\r\n                const name = this._consume(Token.ident, \"Expected argument name.\").toString();\r\n\r\n                this._consume(Token.colon, \"Expected ':' for argument type.\");\r\n                \r\n                const typeAttrs = this._attribute();\r\n                const type = this._type_decl();\r\n                type.attributes = typeAttrs;\r\n\r\n                args.push(new AST(\"arg\", { name, attributes: argAttrs, type }));\r\n            } while (this._match(Token.comma));\r\n        }\r\n\r\n        this._consume(Token.paren_right, \"Expected ')' after function arguments.\");\r\n\r\n        let _return = null;\r\n        if (this._match(Token.arrow)) {\r\n            const attrs = this._attribute();\r\n            _return = this._type_decl();\r\n            _return.attributes = attrs;\r\n        }\r\n\r\n        const body = this._compound_statement();\r\n\r\n        return new AST(\"function\", { name, args, return: _return, body });\r\n    }\r\n\r\n    _compound_statement() {\r\n        // brace_left statement* brace_right\r\n        const statements = [];\r\n        this._consume(Token.brace_left, \"Expected '{' for block.\");\r\n        while (!this._check(Token.brace_right)) {\r\n            const statement = this._statement();\r\n            if (statement)\r\n                statements.push(statement);\r\n        }\r\n        this._consume(Token.brace_right, \"Expected '}' for block.\");\r\n\r\n        return statements;\r\n    }\r\n\r\n    _statement() {\r\n        // semicolon\r\n        // return_statement semicolon\r\n        // if_statement\r\n        // switch_statement\r\n        // loop_statement\r\n        // for_statement\r\n        // func_call_statement semicolon\r\n        // variable_statement semicolon\r\n        // break_statement semicolon\r\n        // continue_statement semicolon\r\n        // discard semicolon\r\n        // assignment_statement semicolon\r\n        // compound_statement\r\n        // increment_statement semicolon\r\n        // decrement_statement semicolon\r\n        // static_assert_statement semicolon\r\n\r\n        // Ignore any stand-alone semicolons\r\n        while (this._match(Token.semicolon) && !this._isAtEnd());\r\n\r\n        if (this._check(Keyword.if))\r\n            return this._if_statement();\r\n\r\n        if (this._check(Keyword.switch))\r\n            return this._switch_statement();\r\n\r\n        if (this._check(Keyword.loop))\r\n            return this._loop_statement();\r\n\r\n        if (this._check(Keyword.for))\r\n            return this._for_statement();\r\n\r\n        if (this._check(Keyword.while))\r\n            return this._while_statement();\r\n\r\n        if (this._check(Keyword.static_assert))\r\n            return this._static_assert_statement();\r\n\r\n        if (this._check(Token.brace_left))\r\n            return this._compound_statement();\r\n\r\n        let result = null;\r\n        if (this._check(Keyword.return))\r\n            result = this._return_statement();\r\n        else if (this._check([Keyword.var, Keyword.let, Keyword.const]))\r\n            result = this._variable_statement();\r\n        else if (this._match(Keyword.discard))\r\n            result = new AST(\"discard\");\r\n        else if (this._match(Keyword.break))\r\n            result = new AST(\"break\");\r\n        else if (this._match(Keyword.continue))\r\n            result = new AST(\"continue\");\r\n        else \r\n            result = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();\r\n        \r\n        if (result != null)\r\n            this._consume(Token.semicolon, \"Expected ';' after statement.\");\r\n\r\n        return result;\r\n    }\r\n    \r\n    _static_assert_statement() {\r\n        if (!this._match(Keyword.static_assert))\r\n            return null;\r\n        let expression = this._optional_paren_expression();\r\n        return new AST(\"static_assert\", { expression });\r\n    }\r\n\r\n    _while_statement() {\r\n        if (!this._match(Keyword.while))\r\n            return null;\r\n        let condition = this._optional_paren_expression();\r\n        const block = this._compound_statement();\r\n        return new AST(\"while\", { condition, block });\r\n    }\r\n\r\n    _for_statement() {\r\n        // for paren_left for_header paren_right compound_statement\r\n        if (!this._match(Keyword.for))\r\n            return null;\r\n\r\n        this._consume(Token.paren_left, \"Expected '('.\");\r\n\r\n        // for_header: (variable_statement assignment_statement func_call_statement)? semicolon short_circuit_or_expression? semicolon (assignment_statement func_call_statement)?\r\n        const init = !this._check(Token.semicolon) ? this._for_init() : null;\r\n        this._consume(Token.semicolon, \"Expected ';'.\");\r\n        const condition = !this._check(Token.semicolon) ? this._short_circuit_or_expression() : null;\r\n        this._consume(Token.semicolon, \"Expected ';'.\");\r\n        const increment = !this._check(Token.paren_right) ? this._for_increment() : null;\r\n\r\n        this._consume(Token.paren_right, \"Expected ')'.\");\r\n\r\n        const body = this._compound_statement();\r\n\r\n        return new AST(\"for\", { init, condition, increment, body });\r\n    }\r\n\r\n    _for_init() {\r\n        // (variable_statement assignment_statement func_call_statement)?\r\n        return this._variable_statement() || this._func_call_statement() || this._assignment_statement();\r\n    }\r\n\r\n    _for_increment() {\r\n        // (assignment_statement func_call_statement increment_statement)?\r\n        return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();\r\n    }\r\n\r\n    _variable_statement() {\r\n        // variable_decl\r\n        // variable_decl equal short_circuit_or_expression\r\n        // let (ident variable_ident_decl) equal short_circuit_or_expression\r\n        // const (ident variable_ident_decl) equal short_circuit_or_expression\r\n        if (this._check(Keyword.var)) {\r\n            const _var = this._variable_decl();\r\n            let value = null;\r\n            if (this._match(Token.equal))\r\n                value = this._short_circuit_or_expression();\r\n\r\n            return new AST(\"var\", { var: _var, value });\r\n        }\r\n\r\n        if (this._match(Keyword.let)) {\r\n            const name = this._consume(Token.ident, \"Expected name for let.\").toString();\r\n            let type = null;\r\n            if (this._match(Token.colon)) {\r\n                const typeAttrs = this._attribute();\r\n                type = this._type_decl();\r\n                type.attributes = typeAttrs;\r\n            }\r\n            this._consume(Token.equal, \"Expected '=' for let.\");\r\n            const value = this._short_circuit_or_expression();\r\n            return new AST(\"let\", { name, type, value });\r\n        }\r\n\r\n        if (this._match(Keyword.const)) {\r\n            const name = this._consume(Token.ident, \"Expected name for const.\").toString();\r\n            let type = null;\r\n            if (this._match(Token.colon)) {\r\n                const typeAttrs = this._attribute();\r\n                type = this._type_decl();\r\n                type.attributes = typeAttrs;\r\n            }\r\n            this._consume(Token.equal, \"Expected '=' for const.\");\r\n            const value = this._short_circuit_or_expression();\r\n            return new AST(\"const\", { name, type, value });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _increment_decrement_statement() {\r\n        const savedPos = this._current;\r\n\r\n        const _var = this._unary_expression();\r\n        if (_var == null)\r\n            return null;\r\n\r\n        if (!this._check(Token.increment_operators)) {\r\n            this._current = savedPos;\r\n            return null;\r\n        }\r\n\r\n        const type = this._consume(Token.increment_operators, \"Expected increment operator\");\r\n\r\n        return new AST(\"increment\", { type, var: _var });\r\n    }\r\n\r\n    _assignment_statement() {\r\n        // (unary_expression underscore) equal short_circuit_or_expression\r\n        let _var = null;\r\n\r\n        if (this._check(Token.brace_right))\r\n            return null;\r\n\r\n        let isUnderscore = this._match(Token.underscore);\r\n        if (!isUnderscore)\r\n            _var = this._unary_expression();\r\n\r\n        if (!isUnderscore && _var == null)\r\n            return null;\r\n\r\n        const type = this._consume(Token.assignment_operators, \"Expected assignment operator.\");\r\n\r\n        const value = this._short_circuit_or_expression();\r\n\r\n        return new AST(\"assign\", { type, var: _var, value });\r\n    }\r\n\r\n    _func_call_statement() {\r\n        // ident argument_expression_list\r\n        if (!this._check(Token.ident))\r\n            return null;\r\n\r\n        const savedPos = this._current;\r\n        const name = this._consume(Token.ident, \"Expected function name.\");\r\n        const args = this._argument_expression_list();\r\n\r\n        if (args === null) {\r\n            this._current = savedPos;\r\n            return null;\r\n        }\r\n\r\n        return new AST(\"call\", { name, args });\r\n    }\r\n\r\n    _loop_statement() {\r\n        // loop brace_left statement* continuing_statement? brace_right\r\n        if (!this._match(Keyword.loop))\r\n            return null;\r\n\r\n        this._consume(Token.brace_left, \"Expected '{' for loop.\");\r\n\r\n        // statement*\r\n        const statements = [];\r\n        let statement = this._statement();\r\n        while (statement !== null) {\r\n            statements.push(statement);\r\n            statement = this._statement();\r\n        }\r\n\r\n        // continuing_statement: continuing compound_statement\r\n        let continuing = null;\r\n        if (this._match(Keyword.continuing))\r\n            continuing = this._compound_statement();\r\n\r\n        this._consume(Token.brace_right, \"Expected '}' for loop.\");\r\n\r\n        return new AST(\"loop\", { statements, continuing });\r\n    }\r\n\r\n    _switch_statement() {\r\n        // switch optional_paren_expression brace_left switch_body+ brace_right\r\n        if (!this._match(Keyword.switch))\r\n            return null;\r\n\r\n        const condition = this._optional_paren_expression();\r\n        this._consume(Token.brace_left);\r\n        const body = this._switch_body();\r\n        if (body == null || body.length == 0)\r\n            throw this._error(this._previous(), \"Expected 'case' or 'default'.\");\r\n        this._consume(Token.brace_right);\r\n        return new AST(\"switch\", { condition, body });\r\n    }\r\n\r\n    _switch_body() {\r\n        // case case_selectors colon brace_left case_body? brace_right\r\n        // default colon brace_left case_body? brace_right\r\n        const cases = [];\r\n        if (this._match(Keyword.case)) {\r\n            this._consume(Keyword.case);\r\n            const selector = this._case_selectors();\r\n            this._consume(Token.colon, \"Exected ':' for switch case.\");\r\n            this._consume(Token.brace_left, \"Exected '{' for switch case.\");\r\n            const body = this._case_body();\r\n            this._consume(Token.brace_right, \"Exected '}' for switch case.\");\r\n            cases.push(new AST(\"case\", { selector, body }));\r\n        }\r\n\r\n        if (this._match(Keyword.default)) {\r\n            this._consume(Token.colon, \"Exected ':' for switch default.\");\r\n            this._consume(Token.brace_left, \"Exected '{' for switch default.\");\r\n            const body = this._case_body();\r\n            this._consume(Token.brace_right, \"Exected '}' for switch default.\");\r\n            cases.push(new AST(\"default\", { body }));\r\n        }\r\n\r\n        if (this._check([Keyword.default, Keyword.case])) {\r\n            const _cases = this._switch_body();\r\n            cases.push(_cases[0]);\r\n        }\r\n\r\n        return cases;\r\n    }\r\n\r\n    _case_selectors() {\r\n        // const_literal (comma const_literal)* comma?\r\n        const selectors = [this._consume(Token.const_literal, \"Expected constant literal\").toString()];\r\n        while (this._match(Token.comma)) {\r\n            selectors.push(this._consume(Token.const_literal, \"Expected constant literal\").toString());\r\n        }\r\n        return selectors;\r\n    }\r\n\r\n    _case_body() {\r\n        // statement case_body?\r\n        // fallthrough semicolon\r\n        if (this._match(Keyword.fallthrough)) {\r\n            this._consume(Token.semicolon);\r\n            return [];\r\n        }\r\n\r\n        const statement = this._statement();\r\n        if (statement == null)\r\n            return [];\r\n\r\n        const nextStatement = this._case_body();\r\n        if (nextStatement.length == 0)\r\n            return [statement];\r\n\r\n        return [statement, nextStatement[0]];\r\n    }\r\n\r\n    _if_statement() {\r\n        // if optional_paren_expression compound_statement elseif_statement? else_statement?\r\n        if (!this._match(Keyword.if))\r\n            return null;\r\n\r\n        const condition = this._optional_paren_expression();\r\n        const block = this._compound_statement();\r\n\r\n        let elseif = null;\r\n        if (this._match(Keyword.elseif))\r\n            elseif = this._elseif_statement();\r\n\r\n        let _else = null;\r\n        if (this._match(Keyword.else))\r\n            _else = this._compound_statement();\r\n\r\n        return new AST(\"if\", { condition, block, elseif, else: _else });\r\n    }\r\n\r\n    _elseif_statement() {\r\n        // else_if optional_paren_expression compound_statement elseif_statement?\r\n        const elseif = [];\r\n        const condition = this._optional_paren_expression();\r\n        const block = this._compound_statement();\r\n        elseif.push(new AST(\"elseif\", { condition, block }));\r\n        if (this._match(Keyword.elseif))\r\n            elseif.push(this._elseif_statement()[0]);\r\n        return elseif;\r\n    }\r\n\r\n    _return_statement() {\r\n        // return short_circuit_or_expression?\r\n        if (!this._match(Keyword.return))\r\n            return null;\r\n        const value = this._short_circuit_or_expression();\r\n        return new AST(\"return\", { value: value });\r\n    }\r\n\r\n    _short_circuit_or_expression() {\r\n        // short_circuit_and_expression\r\n        // short_circuit_or_expression or_or short_circuit_and_expression\r\n        let expr = this._short_circuit_and_expr();\r\n        while (this._match(Token.or_or)) {\r\n            expr = new AST(\"compareOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._short_circuit_and_expr()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _short_circuit_and_expr() {\r\n        // inclusive_or_expression\r\n        // short_circuit_and_expression and_and inclusive_or_expression\r\n        let expr = this._inclusive_or_expression();\r\n        while (this._match(Token.and_and)) {\r\n            expr = new AST(\"compareOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._inclusive_or_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _inclusive_or_expression() {\r\n        // exclusive_or_expression\r\n        // inclusive_or_expression or exclusive_or_expression\r\n        let expr = this._exclusive_or_expression();\r\n        while (this._match(Token.or)) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._exclusive_or_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _exclusive_or_expression() {\r\n        // and_expression\r\n        // exclusive_or_expression xor and_expression\r\n        let expr = this._and_expression();\r\n        while (this._match(Token.xor)) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._and_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _and_expression() {\r\n        // equality_expression\r\n        // and_expression and equality_expression\r\n        let expr = this._equality_expression();\r\n        while (this._match(Token.and)) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._equality_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n    \r\n    _equality_expression() {\r\n        // relational_expression\r\n        // relational_expression equal_equal relational_expression\r\n        // relational_expression not_equal relational_expression\r\n        const expr = this._relational_expression();\r\n        if (this._match([Token.equal_equal, Token.not_equal])) {\r\n            return new AST(\"compareOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._relational_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _relational_expression() {\r\n        // shift_expression\r\n        // relational_expression less_than shift_expression\r\n        // relational_expression greater_than shift_expression\r\n        // relational_expression less_than_equal shift_expression\r\n        // relational_expression greater_than_equal shift_expression\r\n        let expr = this._shift_expression();\r\n        while (this._match([Token.less_than, Token.greater_than, Token.less_than_equal,\r\n                            Token.greater_than_equal])) {\r\n            expr = new AST(\"compareOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._shift_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _shift_expression() {\r\n        // additive_expression\r\n        // shift_expression shift_left additive_expression\r\n        // shift_expression shift_right additive_expression\r\n        let expr = this._additive_expression();\r\n        while (this._match([Token.shift_left, Token.shift_right])) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._additive_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _additive_expression() {\r\n        // multiplicative_expression\r\n        // additive_expression plus multiplicative_expression\r\n        // additive_expression minus multiplicative_expression\r\n        let expr = this._multiplicative_expression();\r\n        while (this._match([Token.plus, Token.minus])) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._multiplicative_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _multiplicative_expression() {\r\n        // unary_expression\r\n        // multiplicative_expression star unary_expression\r\n        // multiplicative_expression forward_slash unary_expression\r\n        // multiplicative_expression modulo unary_expression\r\n        let expr = this._unary_expression();\r\n        while (this._match([Token.star, Token.forward_slash, Token.modulo])) {\r\n            expr = new AST(\"binaryOp\", {\r\n                operator: this._previous().toString(),\r\n                left: expr,\r\n                right: this._unary_expression()\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n\r\n    _unary_expression() {\r\n        // singular_expression\r\n        // minus unary_expression\r\n        // bang unary_expression\r\n        // tilde unary_expression\r\n        // star unary_expression\r\n        // and unary_expression\r\n        if (this._match([Token.minus, Token.bang, Token.tilde, Token.star, Token.and])) {\r\n            return new AST(\"unaryOp\", {\r\n                operator: this._previous().toString(), right: this._unary_expression() });\r\n        }\r\n        return this._singular_expression();\r\n    }\r\n\r\n    _singular_expression() {\r\n        // primary_expression postfix_expression ?\r\n        const expr = this._primary_expression();\r\n        const p = this._postfix_expression();\r\n        if (p)\r\n            expr.postfix = p;\r\n        return expr;\r\n    }\r\n\r\n    _postfix_expression() {\r\n        // bracket_left short_circuit_or_expression bracket_right postfix_expression?\r\n        if (this._match(Token.bracket_left)) {\r\n            const expr = this._short_circuit_or_expression();\r\n            this._consume(Token.bracket_right, \"Expected ']'.\");\r\n            const p = this._postfix_expression();\r\n            if (p)\r\n                expr.postfix = p;\r\n            return expr;\r\n        }\r\n\r\n        // period ident postfix_expression?\r\n        if (this._match(Token.period)) {\r\n            const name = this._consume(Token.ident, \"Expected member name.\");\r\n            const p = this._postfix_expression();\r\n            if (p)\r\n                name.postfix = p;\r\n            return name;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _primary_expression() {\r\n        // ident argument_expression_list?\r\n        if (this._match(Token.ident)) {\r\n            const name = this._previous().toString();\r\n            if (this._check(Token.paren_left)) {\r\n                const args = this._argument_expression_list();\r\n                return new AST(\"call_expr\", { name, args });\r\n            }\r\n            return new AST(\"variable_expr\", { name });\r\n        }\r\n\r\n        // const_literal\r\n        if (this._match(Token.const_literal)) {\r\n            return new AST(\"literal_expr\", { value: this._previous().toString() });\r\n        }\r\n\r\n        // paren_expression\r\n        if (this._check(Token.paren_left)) {\r\n            return this._paren_expression();\r\n        }\r\n\r\n        // bitcast less_than type_decl greater_than paren_expression\r\n        if (this._match(Keyword.bitcast)) {\r\n            this._consume(Token.less_than, \"Expected '<'.\");\r\n            const type = this._type_decl();\r\n            this._consume(Token.greater_than, \"Expected '>'.\");\r\n            const value = this._paren_expression();\r\n            return new AST(\"bitcast_expr\", { type, value });\r\n        }\r\n\r\n        // type_decl argument_expression_list\r\n        const type = this._type_decl();\r\n        const args = this._argument_expression_list();\r\n        return new AST(\"typecast_expr\", { type, args });\r\n    }\r\n\r\n    _argument_expression_list() {\r\n        // paren_left ((short_circuit_or_expression comma)* short_circuit_or_expression comma?)? paren_right\r\n        if (!this._match(Token.paren_left))\r\n            return null;\r\n\r\n        const args = [];\r\n        do {\r\n            if (this._check(Token.paren_right))\r\n                break;\r\n            const arg = this._short_circuit_or_expression();\r\n            args.push(arg);\r\n        } while (this._match(Token.comma));\r\n        this._consume(Token.paren_right, \"Expected ')' for agument list\");\r\n\r\n        return args;\r\n    }\r\n\r\n    _optional_paren_expression() {\r\n        // [paren_left] short_circuit_or_expression [paren_right]\r\n        this._match(Token.paren_left);\r\n        const expr = this._short_circuit_or_expression();\r\n        this._match(Token.paren_right);\r\n        return new AST(\"grouping_expr\", { contents: expr });\r\n    }\r\n\r\n    _paren_expression() {\r\n        // paren_left short_circuit_or_expression paren_right\r\n        this._consume(Token.paren_left, \"Expected '('.\");\r\n        const expr = this._short_circuit_or_expression();\r\n        this._consume(Token.paren_right, \"Expected ')'.\");\r\n        return new AST(\"grouping_expr\", { contents: expr });\r\n    }\r\n\r\n    _struct_decl() {\r\n        // attribute* struct ident struct_body_decl\r\n        if (!this._match(Keyword.struct))\r\n            return null;\r\n\r\n        const name = this._consume(Token.ident, \"Expected name for struct.\").toString();\r\n\r\n        // struct_body_decl: brace_left (struct_member comma)* struct_member comma? brace_right\r\n        this._consume(Token.brace_left, \"Expected '{' for struct body.\");\r\n        const members = [];\r\n        while (!this._check(Token.brace_right)) {\r\n            // struct_member: attribute* variable_ident_decl\r\n            const memberAttrs = this._attribute();\r\n\r\n            const memberName = this._consume(Token.ident, \"Expected variable name.\").toString();\r\n\r\n            this._consume(Token.colon, \"Expected ':' for struct member type.\");\r\n\r\n            const typeAttrs = this._attribute();\r\n            const memberType = this._type_decl();\r\n            memberType.attributes = typeAttrs;\r\n            \r\n            if (!this._check(Token.brace_right))\r\n                this._consume(Token.comma, \"Expected ',' for struct member.\");\r\n            else\r\n                this._match(Token.comma); // trailing comma optional.\r\n\r\n            members.push(new AST(\"member\", {\r\n                name: memberName,\r\n                attributes: memberAttrs,\r\n                type: memberType\r\n            }));\r\n        }\r\n\r\n        this._consume(Token.brace_right, \"Expected '}' after struct body.\");\r\n\r\n        return new AST(\"struct\", { name, members });\r\n    }\r\n\r\n    _global_variable_decl() {\r\n        // attribute* variable_decl (equal const_expression)?\r\n        const _var = this._variable_decl();\r\n        if (this._match(Token.equal))\r\n            _var.value = this._const_expression();\r\n        return _var;\r\n    }\r\n\r\n    _global_constant_decl() {\r\n        // attribute* let (ident variable_ident_decl) global_const_initializer?\r\n        if (!this._match(Keyword.let))\r\n            return null;\r\n\r\n        const name = this._consume(Token.ident, \"Expected variable name\");\r\n        let type = null;\r\n        if (this._match(Token.colon)) {\r\n            const attrs = this._attribute();\r\n            type = this._type_decl();\r\n            type.attributes = attrs;\r\n        }\r\n        let value = null;\r\n        if (this._match(Token.equal)) {\r\n            value = this._const_expression();\r\n        }\r\n        return new AST(\"let\", { name: name.toString(), type, value });\r\n    }\r\n\r\n    _const_expression() {\r\n        // type_decl paren_left ((const_expression comma)* const_expression comma?)? paren_right\r\n        // const_literal\r\n        if (this._match(Token.const_literal))\r\n            return this._previous().toString();\r\n        \r\n        const type = this._type_decl();\r\n\r\n        this._consume(Token.paren_left, \"Expected '('.\");\r\n\r\n        let args = [];\r\n        while (!this._check(Token.paren_right)) {\r\n            args.push(this._const_expression());\r\n            if (!this._check(Token.comma))\r\n                break;\r\n            this._advance();\r\n        }\r\n\r\n        this._consume(Token.paren_right, \"Expected ')'.\");\r\n\r\n        return new AST(\"create\", { type, args });\r\n    }\r\n\r\n    _variable_decl() {\r\n        // var variable_qualifier? (ident variable_ident_decl)\r\n        if (!this._match(Keyword.var))\r\n            return null;\r\n\r\n        // variable_qualifier: less_than storage_class (comma access_mode)? greater_than\r\n        let storage = null;\r\n        let access = null;\r\n        if (this._match(Token.less_than)) {\r\n            storage = this._consume(Token.storage_class, \"Expected storage_class.\").toString();\r\n            if (this._match(Token.comma))\r\n                access = this._consume(Token.access_mode, \"Expected access_mode.\").toString();\r\n            this._consume(Token.greater_than, \"Expected '>'.\");\r\n        }\r\n\r\n        const name = this._consume(Token.ident, \"Expected variable name\");\r\n        let type = null;\r\n        if (this._match(Token.colon)) {\r\n            const attrs = this._attribute();\r\n            type = this._type_decl();\r\n            type.attributes = attrs;\r\n        }\r\n\r\n        return new AST(\"var\", { name: name.toString(), type, storage, access });\r\n    }\r\n\r\n    _enable_directive() {\r\n        // enable ident semicolon\r\n        const name = this._consume(Token.ident, \"identity expected.\");\r\n        return new AST(\"enable\", { name: name.toString() });\r\n    }\r\n\r\n    _type_alias() {\r\n        // type ident equal type_decl\r\n        const name = this._consume(Token.ident, \"identity expected.\");\r\n        this._consume(Token.equal, \"Expected '=' for type alias.\");\r\n        const alias = this._type_decl();\r\n        return new AST(\"alias\", { name: name.toString(), alias });\r\n    }\r\n\r\n    _type_decl() {\r\n        // ident\r\n        // bool\r\n        // float32\r\n        // int32\r\n        // uint32\r\n        // vec2 less_than type_decl greater_than\r\n        // vec3 less_than type_decl greater_than\r\n        // vec4 less_than type_decl greater_than\r\n        // mat2x2 less_than type_decl greater_than\r\n        // mat2x3 less_than type_decl greater_than\r\n        // mat2x4 less_than type_decl greater_than\r\n        // mat3x2 less_than type_decl greater_than\r\n        // mat3x3 less_than type_decl greater_than\r\n        // mat3x4 less_than type_decl greater_than\r\n        // mat4x2 less_than type_decl greater_than\r\n        // mat4x3 less_than type_decl greater_than\r\n        // mat4x4 less_than type_decl greater_than\r\n        // atomic less_than type_decl greater_than\r\n        // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n        // array_type_decl\r\n        // texture_sampler_types\r\n\r\n        if (this._check([Token.ident, ...Token.texel_format, Keyword.bool, Keyword.float32, Keyword.int32, Keyword.uint32])) {\r\n            const type = this._advance();\r\n            return new AST(\"type\", { name: type.toString() });\r\n        }\r\n        \r\n        if (this._check(Token.template_types)) {\r\n            let type = this._advance().toString();\r\n            let format = null;\r\n            let access = null;\r\n            if (this._match(Token.less_than)) {\r\n                format = this._type_decl();\r\n                access = null;\r\n                if (this._match(Token.comma))\r\n                    access = this._consume(Token.access_mode, \"Expected access_mode for pointer\").toString();\r\n                this._consume(Token.greater_than, \"Expected '>' for type.\");\r\n            }\r\n            return new AST(type, { name: type, format, access });\r\n        }\r\n\r\n        // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n        if (this._match(Keyword.pointer)) {\r\n            let pointer = this._previous().toString();\r\n            this._consume(Token.less_than, \"Expected '<' for pointer.\");\r\n            const storage = this._consume(Token.storage_class, \"Expected storage_class for pointer\");\r\n            this._consume(Token.comma, \"Expected ',' for pointer.\");\r\n            const decl = this._type_decl();\r\n            let access = null;\r\n            if (this._match(Token.comma))\r\n                access = this._consume(Token.access_mode, \"Expected access_mode for pointer\").toString();\r\n            this._consume(Token.greater_than, \"Expected '>' for pointer.\");\r\n            return new AST(\"pointer\", { name: pointer, storage: storage.toString(), decl, access });\r\n        }\r\n\r\n        // texture_sampler_types\r\n        let type = this._texture_sampler_types();\r\n        if (type)\r\n            return type;\r\n\r\n        // The following type_decl's have an optional attribyte_list*\r\n        const attrs = this._attribute();\r\n\r\n        // attribute* array less_than type_decl (comma element_count_expression)? greater_than\r\n        if (this._match(Keyword.array)) {\r\n            const array = this._previous();\r\n            this._consume(Token.less_than, \"Expected '<' for array type.\");\r\n            const format = this._type_decl();\r\n            let count = null;\r\n            if (this._match(Token.comma))\r\n                count = this._consume(Token.element_count_expression, \"Expected element_count for array.\").toString();\r\n            this._consume(Token.greater_than, \"Expected '>' for array.\");\r\n\r\n            return new AST(\"array\", { name: array.toString(), attributes: attrs, format, count });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _texture_sampler_types() {\r\n        // sampler_type\r\n        if (this._match(Token.sampler_type))\r\n            return new AST(\"sampler\", { name: this._previous().toString() });\r\n\r\n        // depth_texture_type\r\n        if (this._match(Token.depth_texture_type))\r\n            return new AST(\"sampler\", { name: this._previous().toString() });\r\n\r\n        // sampled_texture_type less_than type_decl greater_than\r\n        // multisampled_texture_type less_than type_decl greater_than\r\n        if (this._match(Token.sampled_texture_type) || \r\n            this._match(Token.multisampled_texture_type)) {\r\n            const sampler = this._previous();\r\n            this._consume(Token.less_than, \"Expected '<' for sampler type.\");\r\n            const format = this._type_decl();\r\n            this._consume(Token.greater_than, \"Expected '>' for sampler type.\");\r\n            return new AST(\"sampler\", { name: sampler.toString(), format });\r\n        }\r\n\r\n        // storage_texture_type less_than texel_format comma access_mode greater_than\r\n        if (this._match(Token.storage_texture_type)) {\r\n            const sampler = this._previous();\r\n            this._consume(Token.less_than, \"Expected '<' for sampler type.\");\r\n            const format = this._consume(Token.texel_format, \"Invalid texel format.\").toString();\r\n            this._consume(Token.comma, \"Expected ',' after texel format.\");\r\n            const access = this._consume(Token.access_mode, \"Expected access mode for storage texture type.\").toString();\r\n            this._consume(Token.greater_than, \"Expected '>' for sampler type.\");\r\n            return new AST(\"sampler\", { name: sampler.toString(), format, access });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _attribute() {\r\n        // attr ident paren_left (literal_or_ident comma)* literal_or_ident paren_right\r\n        // attr ident\r\n\r\n        let attributes = [];\r\n\r\n        while (this._match(Token.attr))\r\n        {\r\n            const name = this._consume(Token.attribute_name, \"Expected attribute name\");\r\n            const attr = new AST(\"attribute\", { name: name.toString() });\r\n            if (this._match(Token.paren_left)) {\r\n                // literal_or_ident\r\n                attr.value = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                if (this._check(Token.comma)) {\r\n                    this._advance();\r\n                    attr.value = [attr.value];\r\n                    do {\r\n                        const v = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                        attr.value.push(v);\r\n                    } while (this._match(Token.comma));\r\n                }\r\n                this._consume(Token.paren_right, \"Expected ')'\");\r\n            }\r\n            attributes.push(attr);\r\n        }\r\n\r\n        // Deprecated:\r\n        // attr_left (attribute comma)* attribute attr_right\r\n        while (this._match(Token.attr_left)) {\r\n            if (!this._check(Token.attr_right)) {\r\n                do {\r\n                    const name = this._consume(Token.attribute_name, \"Expected attribute name\");\r\n                    const attr = new AST(\"attribute\", { name: name.toString() });\r\n                    if (this._match(Token.paren_left)) {\r\n                        // literal_or_ident\r\n                        attr.value = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                        if (this._check(Token.comma)) {\r\n                            this._advance();\r\n                            attr.value = [attr.value];\r\n                            do {\r\n                                const v = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                                attr.value.push(v);\r\n                            } while (this._match(Token.comma));\r\n                        }\r\n                        this._consume(Token.paren_right, \"Expected ')'\");\r\n                    }\r\n                    attributes.push(attr);\r\n                } while (this._match(Token.comma));\r\n\r\n            }\r\n            // Consume ]]\r\n            this._consume(Token.attr_right, \"Expected ']]' after attribute declarations\");\r\n        }\r\n\r\n        if (attributes.length == 0)\r\n            return null;\r\n\r\n        return attributes;\r\n    }\r\n}\r\n\r\n/**\r\n * @author Brendan Duncan / https://github.com/brendan-duncan\r\n */\r\n\r\nclass WgslReflect {\r\n    constructor(code) {\r\n        if (code)\r\n            this.initialize(code);\r\n    }\r\n\r\n    initialize(code) {\r\n        const parser = new WgslParser();\r\n        this.ast = parser.parse(code);\r\n\r\n        // All top-level structs in the shader.\r\n        this.structs = [];\r\n        // All top-level uniform vars in the shader.\r\n        this.uniforms = [];\r\n        // All top-level storage vars in the shader.\r\n        this.storage = [];\r\n        // All top-level texture vars in the shader;\r\n        this.textures = [];\r\n        // All top-level sampler vars in the shader.\r\n        this.samplers = [];\r\n        // All top-level functions in the shader.\r\n        this.functions = [];\r\n        // All top-level type aliases in the shader.\r\n        this.aliases = [];\r\n        // All entry functions in the shader: vertex, fragment, and/or compute.\r\n        this.entry = {\r\n            vertex: [],\r\n            fragment: [],\r\n            compute: []\r\n        };\r\n\r\n        for (const node of this.ast) {\r\n            if (node._type == \"struct\")\r\n                this.structs.push(node);\r\n\r\n            if (node._type == \"alias\")\r\n                this.aliases.push(node);\r\n\r\n            if (this.isUniformVar(node)) {\r\n                const group = this.getAttribute(node, \"group\");\r\n                node.group = group && group.value ? parseInt(group.value) : 0;\r\n                const binding = this.getAttribute(node, \"binding\");\r\n                node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                this.uniforms.push(node);\r\n            }\r\n\r\n            if (this.isStorageVar(node)) {\r\n                const group = this.getAttribute(node, \"group\");\r\n                node.group = group && group.value ? parseInt(group.value) : 0;\r\n                const binding = this.getAttribute(node, \"binding\");\r\n                node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                this.storage.push(node);\r\n            }\r\n\r\n            if (this.isTextureVar(node)) {\r\n                const group = this.getAttribute(node, \"group\");\r\n                node.group = group && group.value ? parseInt(group.value) : 0;\r\n                const binding = this.getAttribute(node, \"binding\");\r\n                node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                this.textures.push(node);\r\n            }\r\n\r\n            if (this.isSamplerVar(node)) {\r\n                const group = this.getAttribute(node, \"group\");\r\n                node.group = group && group.value ? parseInt(group.value) : 0;\r\n                const binding = this.getAttribute(node, \"binding\");\r\n                node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                this.samplers.push(node);\r\n            }\r\n\r\n            if (node._type == \"function\") {\r\n                this.functions.push(node);\r\n                const vertexStage = this.getAttribute(node, \"vertex\");\r\n                const fragmentStage = this.getAttribute(node, \"fragment\");\r\n                const computeStage = this.getAttribute(node, \"compute\");\r\n                const stage = vertexStage || fragmentStage || computeStage;\r\n                if (stage) {\r\n                    node.inputs = this._getInputs(node);\r\n                    if (this.entry[stage.name])\r\n                        this.entry[stage.name].push(node);\r\n                    else\r\n                        this.entry[stage.name] = [node];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    isTextureVar(node) {\r\n        return node._type == \"var\" && WgslReflect.TextureTypes.indexOf(node.type.name) != -1;\r\n    }\r\n\r\n    isSamplerVar(node) {\r\n        return node._type == \"var\" && WgslReflect.SamplerTypes.indexOf(node.type.name) != -1;\r\n    }\r\n\r\n    isUniformVar(node) {\r\n        return node && node._type == \"var\" && node.storage == \"uniform\";\r\n    }\r\n\r\n    isStorageVar(node) {\r\n        return node && node._type == \"var\" && node.storage == \"storage\";\r\n    }\r\n\r\n    _getInputs(args, inputs) {\r\n        if (args._type == \"function\")\r\n            args = args.args;\r\n        if (!inputs)\r\n            inputs = [];\r\n\r\n        for (const arg of args) {\r\n            const input = this._getInputInfo(arg);\r\n            if (input)\r\n                inputs.push(input);\r\n            const struct = this.getStruct(arg.type);\r\n            if (struct)\r\n                this._getInputs(struct.members, inputs);\r\n        }\r\n\r\n        return inputs;\r\n    }\r\n\r\n    _getInputInfo(node) {\r\n        const location = this.getAttribute(node, \"location\") || this.getAttribute(node, \"builtin\");\r\n        if (location) {\r\n            let input = {\r\n                name: node.name,\r\n                type: node.type,\r\n                input: node,\r\n                locationType: location.name,\r\n                location: this._parseInt(location.value)\r\n            };\r\n            const interpolation = this.getAttribute(node, \"interpolation\");\r\n            if (interpolation)\r\n                input.interpolation = interpolation.value;\r\n            return input;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _parseInt(s) {\r\n        const n = parseInt(s);\r\n        return isNaN(n) ? s : n;\r\n    }\r\n\r\n    getAlias(name) {\r\n        if (!name) return null;\r\n        if (name.constructor === AST) {\r\n            if (name._type != \"type\")\r\n                return null;\r\n            name = name.name;\r\n        }\r\n        for (const u of this.aliases) {\r\n            if (u.name == name)\r\n                return u.alias;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getStruct(name) {\r\n        if (!name) return null;\r\n        if (name.constructor === AST) {\r\n            if (name._type == \"struct\")\r\n                return name;\r\n            if (name._type != \"type\")\r\n                return null;\r\n            name = name.name;\r\n        }\r\n        for (const u of this.structs) {\r\n            if (u.name == name)\r\n                return u;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getAttribute(node, name) {\r\n        if (!node || !node.attributes) return null;\r\n        for (let a of node.attributes) {\r\n            if (a.name == name)\r\n                return a;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getBindGroups() {\r\n        const groups = [];\r\n\r\n        function _makeRoom(group, binding) {\r\n            if (group >= groups.length)\r\n                groups.length = group + 1;\r\n            if (groups[group] === undefined)\r\n                groups[group] = [];\r\n\r\n            if (binding >= groups[group].length)\r\n                groups[group].length = binding + 1;\r\n        }\r\n\r\n        for (const u of this.uniforms) {\r\n            _makeRoom(u.group, u.binding);\r\n            const group = groups[u.group];\r\n            group[u.binding] = { type: 'buffer', resource: this.getUniformBufferInfo(u) };\r\n        }\r\n        \r\n        for (const u of this.storage) {\r\n            _makeRoom(u.group, u.binding);\r\n            const group = groups[u.group];\r\n            group[u.binding] = { type: 'storage', resource: this.getStorageBufferInfo(u) };\r\n        }\r\n\r\n        for (const t of this.textures) {\r\n            _makeRoom(t.group, t.binding);\r\n            const group = groups[t.group];\r\n            group[t.binding] = { type: 'texture', resource: t };\r\n        }\r\n\r\n        for (const t of this.samplers) {\r\n            _makeRoom(t.group, t.binding);\r\n            const group = groups[t.group];\r\n            group[t.binding] = { type: 'sampler', resource: t };\r\n        }\r\n\r\n        return groups;\r\n    }\r\n\r\n    getStorageBufferInfo(node) {\r\n        if (!this.isStorageVar(node))\r\n            return null;\r\n\r\n        let group = this.getAttribute(node, \"group\");\r\n        let binding = this.getAttribute(node, \"binding\");\r\n\r\n        group = group && group.value ? parseInt(group.value) : 0;\r\n        binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n\r\n        let info = this._getUniformInfo(node);\r\n\r\n        return {\r\n            ...info,\r\n            group,\r\n            binding,\r\n        }\r\n    }\r\n\r\n    /// Returns information about a struct type, null if the type is not a struct.\r\n    /// {\r\n    ///     name: String,\r\n    ///     type: Object,\r\n    ///     align: Int,\r\n    ///     size: Int,\r\n    ///     members: Array,\r\n    ///     isArray: Bool\r\n    ///     isStruct: Bool\r\n    /// }\r\n    getStructInfo(node) {\r\n        if (!node)\r\n            return null;\r\n \r\n        const struct = node._type === 'struct' ? node : this.getStruct(node.type);\r\n        if (!struct)\r\n            return null;\r\n\r\n        let offset = 0;\r\n        let lastSize = 0;\r\n        let lastOffset = 0;\r\n        let structAlign = 0;\r\n        let buffer = { name: node.name, type: node.type, align: 0, size: 0, members: [] };\r\n\r\n        for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {\r\n            let member = struct.members[mi];\r\n            let name = member.name;\r\n\r\n            let info = this.getTypeInfo(member);\r\n            if (!info)\r\n                continue;\r\n\r\n            let type = member.type;\r\n            let align = info.align;\r\n            let size = info.size;\r\n            offset = this._roundUp(align, offset + lastSize);\r\n            lastSize = size;\r\n            lastOffset = offset;\r\n            structAlign = Math.max(structAlign, align);\r\n            let isArray = member.type._type === \"array\";\r\n            let s = this.getStruct(type) || (isArray ? this.getStruct(member.type.format.name) : null);\r\n            let isStruct = !!s;\r\n            let si = isStruct ? this.getStructInfo(s) : undefined;\r\n            let arrayStride = si?.size ?? isArray ? this.getTypeInfo(member.type.format)?.size : this.getTypeInfo(member.type)?.size;\r\n            \r\n            let arrayCount = parseInt(member.type.count ?? 0);\r\n            let members = isStruct ? si?.members : undefined;\r\n\r\n            let u = { name, offset, size, type, member, isArray, arrayCount, arrayStride, isStruct, members };\r\n            buffer.members.push(u);\r\n        }\r\n\r\n        buffer.size = this._roundUp(structAlign, lastOffset + lastSize);\r\n        buffer.align = structAlign;\r\n        buffer.isArray = false;\r\n        buffer.isStruct = true;\r\n        buffer.arrayCount = 0;\r\n\r\n        return buffer;\r\n    }\r\n\r\n    _getUniformInfo(node) {\r\n        let info = this.getStructInfo(node);\r\n        if (info)\r\n            return info;\r\n\r\n        info = this.getTypeInfo(node.type);\r\n        if (!info)\r\n            return info;\r\n\r\n        let s = this.getStruct(node.type.format?.name);\r\n        let si = s ? this.getStructInfo(s) : undefined;\r\n\r\n        info.isArray = node.type._type === \"array\";\r\n        info.isStruct = !!s;\r\n                \r\n        info.members = info.isStruct ? si?.members : undefined;\r\n        info.name = node.name;\r\n        info.type = node.type;\r\n        info.arrayStride = si?.size ?? info.isArray ?\r\n            this.getTypeInfo(node.type.format)?.size :\r\n            this.getTypeInfo(node.type)?.size;\r\n        info.arrayCount = parseInt(node.type.count ?? 0);\r\n        return info;\r\n    }\r\n\r\n    getUniformBufferInfo(node) {\r\n        if (!this.isUniformVar(node))\r\n            return null;\r\n\r\n        let group = this.getAttribute(node, \"group\");\r\n        let binding = this.getAttribute(node, \"binding\");\r\n\r\n        group = group && group.value ? parseInt(group.value) : 0;\r\n        binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n\r\n        let info = this._getUniformInfo(node);\r\n\r\n        return {\r\n            ...info,\r\n            group,\r\n            binding,\r\n        }\r\n    }\r\n\r\n    getTypeInfo(type) {\r\n        if (!type)\r\n            return undefined;\r\n\r\n        let explicitSize = 0;\r\n        const sizeAttr = this.getAttribute(type, \"size\");\r\n        if (sizeAttr)\r\n            explicitSize = parseInt(sizeAttr.value);\r\n\r\n        let explicitAlign = 0;\r\n        const alignAttr = this.getAttribute(type, \"align\");\r\n        if (alignAttr)\r\n            explicitAlign = parseInt(alignAttr.value);\r\n\r\n        if (type._type == \"member\")\r\n            type = type.type;\r\n\r\n        if (type._type == \"type\") {\r\n            const alias = this.getAlias(type.name);\r\n            if (alias) {\r\n                type = alias;\r\n            } else {\r\n                const struct = this.getStruct(type.name);\r\n                if (struct)\r\n                    type = struct;\r\n            }\r\n        }\r\n\r\n        const info = WgslReflect.TypeInfo[type.name];\r\n        if (info) {\r\n            return {\r\n                align: Math.max(explicitAlign, info.align),\r\n                size: Math.max(explicitSize, info.size)\r\n            };\r\n        }\r\n        \r\n        if (type.name == \"array\") {\r\n            let align = 8;\r\n            let size = 8;\r\n            // Type                 AlignOf(T)          Sizeof(T)\r\n            // array<E, N>          AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))\r\n            // array<E>             AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))  (N determined at runtime)\r\n            //\r\n            // @stride(Q)\r\n            // array<E, N>          AlignOf(E)          N * Q\r\n            //\r\n            // @stride(Q)\r\n            // array<E>             AlignOf(E)          Nruntime * Q\r\n            //const E = type.format.name;\r\n            const E = this.getTypeInfo(type.format);\r\n            if (E) {\r\n                size = E.size;\r\n                align = E.align;\r\n            }\r\n\r\n            const N = parseInt(type.count || 1);\r\n\r\n            const stride = this.getAttribute(type, \"stride\");\r\n            if (stride)\r\n                size = N * parseInt(stride.value);\r\n            else\r\n                size = N * this._roundUp(align, size);\r\n\r\n            if (explicitSize)\r\n                size = explicitSize;\r\n\r\n            return {\r\n                align: Math.max(explicitAlign, align),\r\n                size: Math.max(explicitSize, size)\r\n            };\r\n        }\r\n\r\n        if (type._type == \"struct\") {\r\n            let align = 0;\r\n            let size = 0;\r\n            // struct S     AlignOf:    max(AlignOfMember(S, M1), ... , AlignOfMember(S, MN))\r\n            //              SizeOf:     roundUp(AlignOf(S), OffsetOfMember(S, L) + SizeOfMember(S, L))\r\n            //                          Where L is the last member of the structure\r\n            let offset = 0;\r\n            let lastSize = 0;\r\n            let lastOffset = 0;\r\n            for (const m of type.members) {\r\n                const mi = this.getTypeInfo(m);\r\n                align = Math.max(mi.align, align);\r\n                offset = this._roundUp(mi.align, offset + lastSize);\r\n                lastSize = mi.size;\r\n                lastOffset = offset;\r\n            }\r\n            size = this._roundUp(align, lastOffset + lastSize);\r\n\r\n            return {\r\n                align: Math.max(explicitAlign, align),\r\n                size: Math.max(explicitSize, size)\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _roundUp(k, n) {\r\n        return Math.ceil(n / k) * k;\r\n    }\r\n}\r\n\r\n\r\n// Type                 AlignOf(T)          Sizeof(T)\r\n// i32, u32, or f32     4                   4\r\n// atomic<T>            4                   4\r\n// vec2<T>              8                   8\r\n// vec3<T>              16                  12\r\n// vec4<T>              16                  16\r\n// mat2x2<f32>          8                   16\r\n// mat3x2<f32>          8                   24\r\n// mat4x2<f32>          8                   32\r\n// mat2x3<f32>          16                  32\r\n// mat3x3<f32>          16                  48\r\n// mat4x3<f32>          16                  64\r\n// mat2x4<f32>          16                  32\r\n// mat3x4<f32>          16                  48\r\n// mat4x4<f32>          16                  64\r\nWgslReflect.TypeInfo = {\r\n    \"i32\": { align: 4, size: 4 },\r\n    \"u32\": { align: 4, size: 4 },\r\n    \"f32\": { align: 4, size: 4 },\r\n    \"atomic\": { align: 4, size: 4 },\r\n    \"vec2\": { align: 8, size: 8 },\r\n    \"vec3\": { align: 16, size: 12 },\r\n    \"vec4\": { align: 16, size: 16 },\r\n    \"mat2x2\": { align: 8, size: 16 },\r\n    \"mat3x2\": { align: 8, size: 24 },\r\n    \"mat4x2\": { align: 8, size: 32 },\r\n    \"mat2x3\": { align: 16, size: 32 },\r\n    \"mat3x3\": { align: 16, size: 48 },\r\n    \"mat4x3\": { align: 16, size: 64 },\r\n    \"mat2x4\": { align: 16, size: 32 },\r\n    \"mat3x4\": { align: 16, size: 48 },\r\n    \"mat4x4\": { align: 16, size: 64 },\r\n};\r\n\r\nWgslReflect.TextureTypes = Token.any_texture_type.map((t) => { return t.name; });\r\nWgslReflect.SamplerTypes = Token.sampler_type.map((t) => { return t.name; });\r\n\r\nexport { AST, Keyword, Token, WgslParser, WgslReflect, WgslScanner };\r\n","import { WgslReflect, Member } from './3rdParty/wgsl_reflect/wgsl_reflect.module';\n\nexport const roundUpToMultipleOf = (v: number, multiple: number) => (((v + multiple - 1) / multiple) | 0) * multiple;\n\n// TODO: fix better?\nexport const isTypedArray = (arr: any) =>\n    arr && typeof arr.length === 'number' && arr.buffer instanceof ArrayBuffer && typeof arr.byteLength === 'number';\n\nexport type TypedArrayConstructor =\n    | Int8ArrayConstructor\n    | Uint8ArrayConstructor\n    | Int16ArrayConstructor\n    | Uint16ArrayConstructor\n    | Int32ArrayConstructor\n    | Uint32ArrayConstructor\n    | Float32ArrayConstructor\n    | Float64ArrayConstructor;\n\nexport type TypedArray =\n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array;\n\nexport class TypedArrayViewGenerator {\n    arrayBuffer: ArrayBuffer;\n    byteOffset: number;\n\n    constructor(sizeInBytes: number) {\n        this.arrayBuffer = new ArrayBuffer(sizeInBytes);\n        this.byteOffset = 0;\n    }\n    align(alignment: number) {\n        this.byteOffset = roundUpToMultipleOf(this.byteOffset, alignment);\n    }\n    pad(numBytes: number) {\n        this.byteOffset += numBytes;\n    }\n    getView<T extends TypedArray>(Ctor: TypedArrayConstructor, numElements: number): T {\n        const view = new Ctor(this.arrayBuffer, this.byteOffset, numElements);\n        this.byteOffset += view.byteLength;\n        return view as T;\n    }\n}\n\nexport interface StructDefinition {\n    fields: FieldDefinitions;\n    size: number;\n}\n\nexport type IntrinsicDefinition = {\n    offset: number;\n    size: number;\n    type: string;\n    numElements?: number;\n};\n\nexport type FieldDefinition = IntrinsicDefinition | StructDefinition | IntrinsicDefinition[] | StructDefinition[];\n\nexport type FieldDefinitions = {\n    [x: string]: FieldDefinition;\n};\n\n\ntype TypeDef = {\n    numElements: number;\n    align: number;\n    size: number;\n    type: string;\n    View: TypedArrayConstructor;\n};\n\nconst typeInfo: Record<string, TypeDef> = {\n    i32: { numElements: 1, align: 4, size: 4, type: 'i32', View: Int32Array },\n    u32: { numElements: 1, align: 4, size: 4, type: 'u32', View: Uint32Array },\n    f32: { numElements: 1, align: 4, size: 4, type: 'f32', View: Float32Array },\n    f16: { numElements: 1, align: 2, size: 2, type: 'u16', View: Uint16Array },\n    'vec2<i32>': { numElements: 2, align:  8, size:  8, type: 'i32', View: Int32Array },\n    'vec2<u32>': { numElements: 2, align:  8, size:  8, type: 'u32', View: Uint32Array },\n    'vec2<f32>': { numElements: 2, align:  8, size:  8, type: 'f32', View: Float32Array },\n    'vec2': { numElements: 2, align:  8, size:  8, type: 'f32', View: Float32Array },\n    'vec2<f16>': { numElements: 2, align:  4, size:  4, type: 'u16', View: Uint16Array },\n    'vec3<i32>': { numElements: 3, align: 16, size: 12, type: 'i32', View: Int32Array },\n    'vec3<u32>': { numElements: 3, align: 16, size: 12, type: 'u32', View: Uint32Array },\n    'vec3<f32>': { numElements: 3, align: 16, size: 12, type: 'f32', View: Float32Array },\n    'vec3': { numElements: 3, align: 16, size: 12, type: 'f32', View: Float32Array },\n    'vec3<f16>': { numElements: 3, align:  8, size:  6, type: 'u16', View: Uint16Array },\n    'vec4<i32>': { numElements: 4, align: 16, size: 16, type: 'i32', View: Int32Array },\n    'vec4<u32>': { numElements: 4, align: 16, size: 16, type: 'u32', View: Uint32Array },\n    'vec4<f32>': { numElements: 4, align: 16, size: 16, type: 'f32', View: Float32Array },\n    'vec4': { numElements: 4, align: 16, size: 16, type: 'f32', View: Float32Array },\n    'vec4<f16>': { numElements: 4, align:  8, size:  8, type: 'u16', View: Uint16Array },\n    // AlignOf(vecR)\tSizeOf(array<vecR, C>)\n    'mat2x2<f32>': { numElements:  8, align:  8, size: 16, type: 'f32', View: Float32Array },\n    'mat2x2': { numElements:  8, align:  8, size: 16, type: 'f32', View: Float32Array },\n    'mat2x2<f16>': { numElements:  4, align:  4, size:  8, type: 'u16', View: Uint16Array },\n    'mat3x2<f32>': { numElements:  8, align:  8, size: 24, type: 'f32', View: Float32Array },\n    'mat3x2': { numElements:  8, align:  8, size: 24, type: 'f32', View: Float32Array },\n    'mat3x2<f16>': { numElements:  8, align:  4, size: 12, type: 'u16', View: Uint16Array },\n    'mat4x2<f32>': { numElements:  8, align:  8, size: 32, type: 'f32', View: Float32Array },\n    'mat4x2': { numElements:  8, align:  8, size: 32, type: 'f32', View: Float32Array },\n    'mat4x2<f16>': { numElements:  8, align:  4, size: 16, type: 'u16', View: Uint16Array },\n    'mat2x3<f32>': { numElements: 12, align: 16, size: 32, type: 'f32', View: Float32Array },\n    'mat2x3': { numElements: 12, align: 16, size: 32, type: 'f32', View: Float32Array },\n    'mat2x3<f16>': { numElements: 12, align:  8, size: 16, type: 'u16', View: Uint16Array },\n    'mat3x3<f32>': { numElements: 12, align: 16, size: 48, type: 'f32', View: Float32Array },\n    'mat3x3': { numElements: 12, align: 16, size: 48, type: 'f32', View: Float32Array },\n    'mat3x3<f16>': { numElements: 12, align:  8, size: 24, type: 'u16', View: Uint16Array },\n    'mat4x3<f32>': { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\n    'mat4x3': { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\n    'mat4x3<f16>': { numElements: 16, align:  8, size: 32, type: 'u16', View: Uint16Array },\n    'mat2x4<f32>': { numElements: 16, align: 16, size: 32, type: 'f32', View: Float32Array },\n    'mat2x4': { numElements: 16, align: 16, size: 32, type: 'f32', View: Float32Array },\n    'mat2x4<f16>': { numElements: 16, align:  8, size: 16, type: 'u16', View: Uint16Array },\n    'mat3x4<f32>': { numElements: 16, align: 16, size: 48, type: 'f32', View: Float32Array },\n    'mat3x4': { numElements: 16, align: 16, size: 48, type: 'f32', View: Float32Array },\n    'mat3x4<f16>': { numElements: 16, align:  8, size: 24, type: 'u16', View: Uint16Array },\n    'mat4x4<f32>': { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\n    'mat4x4': { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\n    'mat4x4<f16>': { numElements: 16, align:  8, size: 32, type: 'u16', View: Uint16Array },\n};\n\nexport type TypedArrayOrViews = TypedArray | Views | Views[];\nexport interface Views {\n  [x: string]: TypedArrayOrViews;\n}\nexport type ArrayBufferViews = {\n    views: TypedArrayOrViews;\n    arrayBuffer: ArrayBuffer;\n}\n\n/**\n * Creates a set of named TypedArray views on an ArrayBuffer\n * @param structDef Definition of the various types of views.\n * @param arrayBuffer Optional ArrayBuffer to use (if one provided one will be created)\n * @param offset Optional offset in existing ArrayBuffer to start the views.\n * @returns A bunch of named TypedArray views and the ArrayBuffer\n */\nexport function makeTypedArrayViews(structDef: StructDefinition, arrayBuffer?: ArrayBuffer, offset?: number): ArrayBufferViews {\n    const baseOffset = offset || 0;\n    const buffer = arrayBuffer || new ArrayBuffer(structDef.size);\n\n    const makeViews = (structDef: StructDefinition): TypedArrayOrViews => {\n        if (Array.isArray(structDef)) {\n            return (structDef as StructDefinition[]).map(elemDef => makeViews(elemDef)) as Views[];\n        } else if (typeof structDef === 'string') {\n            throw Error('unreachable');\n        } else if (structDef.fields) {\n            const views: Views = {};\n            for (const [name, def] of Object.entries(structDef.fields)) {\n                //const { size, offset, type } = def as IntrinsicDefinition;\n                views[name] = makeViews(def as StructDefinition);\n                //if (typeof type === 'string') {\n                //    const { view } = typeInfo[type];\n                //    const numElements = size / view.BYTES_PER_ELEMENT;\n                //    views[name] = new view(buffer, baseOffset + offset, numElements);\n                //} else {\n                //    views[name] = makeViews(def as StructDefinition);\n                //}\n            }\n            return views;\n        } else {\n            const { size, offset, type } = structDef as IntrinsicDefinition;\n            const { View } = typeInfo[type];\n            const numElements = size / View.BYTES_PER_ELEMENT;\n            return new View(buffer, baseOffset + offset, numElements);\n        }\n    };\n    return { views: makeViews(structDef), arrayBuffer: buffer };\n}\n\n/**\n * Given a set of TypeArrayViews and matching JavaScript data\n * sets the content of the views.\n * @param data The new values\n * @param views TypedArray views as returned from {@link makeTypedArrayViews}\n */\nexport function setStructuredView(data: any, views: TypedArrayOrViews): void {\n    if (data === undefined) {\n        return;\n    } else if (isTypedArray(views)) {\n        const view = views as TypedArray;\n        if (view.length === 1 && typeof data === 'number') {\n            view[0] = data;\n        } else {\n            view.set(data as number[]);\n        }\n    } else if (Array.isArray(views)) {\n        const asArray = views as Views[];\n        (data as any[]).forEach((newValue, ndx) => {\n            setStructuredView(newValue, asArray[ndx]);\n        });\n    } else {\n        const asViews = views as Views;\n        for (const [key, newValue] of Object.entries(data)) {\n            const view = asViews[key];\n            if (view) {\n                setStructuredView(newValue, view);\n            }\n        }\n    }\n}\n\nexport type StructuredView = ArrayBufferViews & {\n    /**\n     * Sets the contents of the TypedArrays based on the data passed in\n     * Note: The data may be sparse\n     *\n     * example:\n     *\n     * ```js\n     * const code = `\n     * struct HSL {\n     *   hue: f32,\n     *   sat: f32,\n     *   lum: f32,\n     * };\n     * struct MyUniforms {\n     *    colors: array<HSL, 4>,\n     *    brightness: f32,\n     *    kernel: array<f32, 9>,\n     * };\n     * @group(0) @binding(0) var<uniform> myUniforms: MyUniforms;\n     * `;\n     * const defs = makeShaderDataDefinitions(code);\n     * const myUniformValues = makeStructuredView(defs.uniforms.myUniforms);\n     *\n     * myUniformValues.set({\n     *   colors: [\n     *     ,\n     *     ,\n     *     { hue: 0.5, sat: 1.0, lum: 0.5 },  // only set the 3rd color\n     *   ],\n     *   brightness: 0.8,\n     *   kernel: [\n     *      1, 0, -1,\n     *      2, 0, -2,\n     *      1, 0, -1,\n     *   ],\n     * });\n     * ```\n     *\n     * @param data\n     */\n    set(data: any): void;\n}\n\n/**\n * Given a StructDefinition, create matching TypedArray views\n * @param structDef A StructDefinition as returned from {@link makeShaderDataDefinitions}\n * @param arrayBuffer Optional ArrayBuffer for the views\n * @param offset Optional offset into the ArrayBuffer for the views\n * @returns TypedArray views for the various named fields of the structure as well\n *    as a `set` function to make them easy to set, and the arrayBuffer\n */\nexport function makeStructuredView(structDef: StructDefinition, arrayBuffer?: ArrayBuffer, offset = 0): StructuredView {\n    const views = makeTypedArrayViews(structDef, arrayBuffer, offset);\n    return {\n        ...views,\n        set(data: any) {\n            setStructuredView(data, views.views);\n        },\n    };\n}\n\nexport type StructDefinitions = {\n    [x: string]: StructDefinition;\n}\n\nfunction addMember(reflect: WgslReflect, m: Member, offset: number): [string, StructDefinition | IntrinsicDefinition | IntrinsicDefinition[] | StructDefinition[]] {\n    if (m.isArray) {\n        if (m.isStruct) {\n            return [\n                m.name,\n                new Array(m.arrayCount).fill(0).map((_, ndx) => {\n                    return addMembers(reflect, m.members!, m.size / m.arrayCount, offset + (m.offset || 0) + m.size / m.arrayCount * ndx);\n                }),\n            ];\n        } else {\n            return [\n                m.name,\n                {\n                    offset: offset + (m.offset || 0),\n                    size: m.size,\n                    type: m.type.format!.name!,\n                    numElements: m.arrayCount,\n                },\n            ];\n        }\n    } else if (m.isStruct) {\n        return [\n            m.name,\n            addMembers(reflect, m.members!, m.size, offset + (m.offset || 0)),\n        ];\n    } else {\n        return [\n            m.name,\n            {\n                offset: offset + (m.offset || 0),\n                size: m.size,\n                type: m.type?.name || m.name,\n            },\n        ];\n    }\n}\n\nfunction addMembers(reflect: WgslReflect, members: Member[], size: number, offset = 0): StructDefinition {\n    const fields: FieldDefinitions = Object.fromEntries(members.map(m => {\n        return addMember(reflect, m, offset);\n    }));\n\n    return {\n        fields,\n        size,\n    };\n}\n\ntype ShaderDataDefinitions = {\n    uniforms: StructDefinitions,\n    storages: StructDefinitions,\n    structs: StructDefinitions,\n};\n\n/**\n * Given a WGSL shader, returns data definitions for structures,\n * uniforms, and storage buffers\n *\n * Example:\n *\n * ```js\n * const code = `\n * struct MyStruct {\n *    color: vec4<f32>,\n *    brightness: f32,\n *    kernel: array<f32, 9>,\n * };\n * @group(0) @binding(0) var<uniform> myUniforms: MyUniforms;\n * `;\n * const defs = makeShaderDataDefinitions(code);\n * const myUniformValues = makeStructuredView(defs.uniforms.myUniforms);\n *\n * myUniformValues.set({\n *   color: [1, 0, 1, 1],\n *   brightness: 0.8,\n *   kernel: [\n *      1, 0, -1,\n *      2, 0, -2,\n *      1, 0, -1,\n *   ],\n * });\n * device.queue.writeBuffer(uniformBuffer, 0, myUniformValues.arrayBuffer);\n * ```\n *\n * @param code WGSL shader. Note: it is not required for this to be a complete shader\n * @returns definitions of the structures by name. Useful for passing to {@link makeStructuredView}\n */\nexport function makeShaderDataDefinitions(code: string): ShaderDataDefinitions {\n    const reflect = new WgslReflect(code);\n\n    const structs = Object.fromEntries(reflect.structs.map(struct => {\n        const info = reflect.getStructInfo(struct);\n        return [struct.name, addMembers(reflect, info.members, info.size)];\n    }));\n\n    const uniforms = Object.fromEntries(reflect.uniforms.map(uniform => {\n        const info = reflect.getUniformBufferInfo(uniform);\n        return [uniform.name, addMember(reflect, info, 0)[1]];\n    }));\n\n    const storages = Object.fromEntries(reflect.storage.map(uniform => {\n        const info = reflect.getStorageBufferInfo(uniform);\n        return [uniform.name, addMember(reflect, info, 0)[1]];\n    }));\n\n    return {\n        structs,\n        storages,\n        uniforms,\n    };\n}\n\ntype ViewsByCtor = Map<TypedArrayConstructor, TypedArray>;\nconst s_views = new WeakMap<ArrayBuffer, ViewsByCtor>();\n\n\nfunction getViewsByCtor(arrayBuffer: ArrayBuffer): ViewsByCtor {\n    let viewsByCtor = s_views.get(arrayBuffer);\n    if (!viewsByCtor) {\n        viewsByCtor = new Map();\n        s_views.set(arrayBuffer, viewsByCtor);\n    }\n    return viewsByCtor;\n}\n\nfunction getView<T extends TypedArray>(arrayBuffer: ArrayBuffer, Ctor: TypedArrayConstructor): T {\n    const viewsByCtor = getViewsByCtor(arrayBuffer);\n    let view = viewsByCtor.get(Ctor);\n    if (!view) {\n        view = new Ctor(arrayBuffer);\n        viewsByCtor.set(Ctor, view);\n    }\n    return view;\n}\n\nexport function setStructuredValues(fieldDef: FieldDefinition, data: any, arrayBuffer: ArrayBuffer, offset = 0) {\n    const asIntrinsicDefinition = fieldDef as IntrinsicDefinition;\n    if (asIntrinsicDefinition.type) {\n        const type = typeInfo[asIntrinsicDefinition.type];\n        const view = getView(arrayBuffer, type.View);\n        const index = (offset + asIntrinsicDefinition.offset) / view.BYTES_PER_ELEMENT;\n        if (typeof data === 'number') {\n            view[index] = data;\n        } else {\n            view.set(data, index);\n        }\n    } else if (Array.isArray(fieldDef)) {\n        // It's IntrinsicDefinition[] or StructDefinition[]\n        data.forEach((newValue: any, ndx: number) => {\n            setStructuredValues(fieldDef[ndx], newValue, arrayBuffer, offset);\n        });\n    } else {\n        // It's StructDefinition\n        const asStructDefinition = fieldDef as StructDefinition;\n        for (const [key, newValue] of Object.entries(data)) {\n            const fieldDef = asStructDefinition.fields[key];\n            if (fieldDef) {\n                setStructuredValues(fieldDef, newValue, arrayBuffer, offset);\n            }\n        }\n    }\n}"],"names":[],"mappings":"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"}